<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BoardGame Collection Manager</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html5-qrcode/2.3.8/html5-qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script>
        // Fallback if primary CDN fails
        if (typeof Html5Qrcode === 'undefined') {
            document.write('<script src="https://unpkg.com/html5-qrcode@2.3.8/html5-qrcode.min.js"><\/script>');
        }
    </script>
    <style>
        #search-section, #stats-section, #players-section, 
        #sessions-section, #bulk-section, #bgg-section, #settings-section {
            min-height: 100px;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: #f5f5f5;
            color: #333;
            min-height: 100vh;
        }
        
        header {
            background-color: #2c3e50;
            color: white;
            padding: 1rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 100;
        }
        
        h1 {
            font-size: 1.5rem;
            text-align: center;
        }
        
        main {
            padding: 1rem;
            max-width: 800px;
            margin: 0 auto;
            width: 100%;
        }
        
        /* CRITICAL: Force hidden to work */
        .hidden {
            display: none !important;
            visibility: hidden !important;
            height: 0 !important;
            overflow: hidden !important;
        }
        
        /* CRITICAL: Force sections to display when not hidden */
        main > div:not(.hidden):not(.mode-selector) {
            display: block !important;
        }
        
        .mode-selector {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5rem;
            margin-bottom: 1.5rem;
        }
        
        .mode-btn {
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            font-size: 0.8rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            background-color: #ecf0f1;
            color: #2c3e50;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.25rem;
        }
        
        .mode-btn .icon {
            font-size: 1.2rem;
        }
        
        .mode-btn.active {
            background-color: #3498db;
            color: white;
        }
        
        .mode-btn:hover:not(.active) {
            background-color: #bdc3c7;
        }
        
        .scan-container {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }
        
        #reader {
            width: 100%;
            max-width: 500px;
            margin: 0 auto;
        }
        
        .action-buttons {
            display: flex;
            gap: 0.5rem;
            margin-top: 1rem;
        }
        
        .btn {
            flex: 1;
            padding: 0.75rem;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        .btn-primary {
            background-color: #27ae60;
            color: white;
        }
        
        .btn-primary:hover {
            background-color: #229954;
        }
        
        .btn-secondary {
            background-color: #e74c3c;
            color: white;
        }
        
        .btn-secondary:hover {
            background-color: #c0392b;
        }
        
        .btn-info {
            background-color: #3498db;
            color: white;
        }
        
        .btn-info:hover {
            background-color: #2980b9;
        }
        
        .results {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 1rem;
        }
        
        .result-item {
            padding: 0.75rem;
            border-bottom: 1px solid #ecf0f1;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .result-item:last-child {
            border-bottom: none;
        }
        
        .result-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
        }
        
        .result-item-content {
            flex: 1;
        }
        
        .game-title {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .game-location {
            font-size: 0.875rem;
            color: #7f8c8d;
            margin-top: 0.25rem;
        }
        
        .game-thumbnail {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
        }
        
        .status-message {
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            text-align: center;
            font-weight: 500;
        }
        
        .status-success {
            background-color: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }
        
        .status-error {
            background-color: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }
        
        .workflow-state {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
            padding: 0.75rem;
            border-radius: 8px;
            margin: 1rem 0;
            text-align: center;
        }
        
        .setup-section {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-top: 1rem;
        }
        
        .setup-section h3 {
            margin-bottom: 1rem;
            color: #2c3e50;
        }
        
        .setup-section input, .setup-section select {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            margin-bottom: 0.5rem;
            font-size: 1rem;
        }
        
        .setup-instructions {
            background: #e8f4f8;
            padding: 1rem;
            border-radius: 8px;
            margin-top: 1rem;
            font-size: 0.875rem;
            line-height: 1.6;
        }
        
        .search-container {
            background: white;
            border-radius: 12px;
            padding: 1rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin-bottom: 1rem;
        }
        
        .search-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-size: 1rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .stat-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            text-align: center;
        }
        
        .stat-value {
            font-size: 2rem;
            font-weight: bold;
            color: #3498db;
        }
        
        .stat-label {
            color: #7f8c8d;
            margin-top: 0.5rem;
        }
        
        .bulk-actions {
            background: #ecf0f1;
            padding: 1rem;
            border-radius: 8px;
            margin: 1rem 0;
            display: flex;
            gap: 0.5rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        .tabs {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            border-bottom: 2px solid #ecf0f1;
        }
        
        .tab {
            padding: 0.5rem 1rem;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            cursor: pointer;
            font-weight: 600;
            color: #7f8c8d;
            transition: all 0.3s;
        }
        
        .tab.active {
            background-color: #3498db !important;
            color: white !important;
        }
        
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        
        .file-input-label {
            padding: 0.5rem 1rem;
            background-color: #3498db;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            display: inline-block;
            font-size: 0.875rem;
        }
        
        /* New styles for advanced features */
        .player-select {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            margin: 1rem 0;
        }
        
        .player-chip {
            background: #e8f4f8;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
            transition: all 0.3s;
            border: 2px solid transparent;
        }
        
        .player-chip.selected {
            background: #3498db;
            color: white;
            border-color: #2980b9;
        }
        
        .chart-container {
            position: relative;
            height: 300px;
            margin: 2rem 0;
        }
        
        .session-template {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin: 0.5rem 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .rating-input {
            display: flex;
            gap: 0.25rem;
            margin: 0.5rem 0;
        }
        
        .star {
            font-size: 1.5rem;
            cursor: pointer;
            color: #ddd;
        }
        
        .star.filled {
            color: #f1c40f;
        }
        
        .player-stats-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 1rem 0;
        }
        
        .win-rate-bar {
            height: 20px;
            background: #ecf0f1;
            border-radius: 10px;
            overflow: hidden;
            margin: 0.5rem 0;
        }
        
        .win-rate-fill {
            height: 100%;
            background: #27ae60;
            transition: width 0.3s;
        }
        
        .player-tab-content {
            margin-top: 1rem;
        }
        
        .player-card {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            margin: 1rem 0;
            position: relative;
        }
        
        .player-card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .player-card h4 {
            margin: 0;
            color: #2c3e50;
        }
        
        .player-card-actions {
            display: flex;
            gap: 0.5rem;
        }
        
        .player-card-actions button {
            padding: 0.25rem 0.5rem;
            font-size: 0.875rem;
        }
        
        .player-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        .player-stat-item {
            text-align: center;
            padding: 1rem;
            background: #f8f9fa;
            border-radius: 8px;
        }
        
        .player-stat-value {
            font-size: 1.5rem;
            font-weight: bold;
            color: #3498db;
        }
        
        .player-stat-label {
            font-size: 0.875rem;
            color: #7f8c8d;
            margin-top: 0.25rem;
        }
        
        .session-history-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin: 0.5rem 0;
        }
        
        .session-history-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
            font-weight: 600;
        }
        
        .session-history-games {
            font-size: 0.875rem;
            color: #7f8c8d;
        }
        
        /* New styles for game history feature */
        .game-history-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none; /* Changed from flex to none */
            align-items: center;
            justify-content: center;
            z-index: 1000;
            padding: 1rem;
            overflow-y: auto;
        }
        
        /* Add this new rule to show the modal when not hidden */
        .game-history-modal:not(.hidden) {
            display: flex;
        }
        
        .game-history-content {
            background: white;
            border-radius: 12px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
        }
        
        .game-history-header {
            background: #2c3e50;
            color: white;
            padding: 1.5rem;
            border-radius: 12px 12px 0 0;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        .game-history-header h2 {
            margin: 0;
            font-size: 1.5rem;
        }
        
        .game-history-close {
            position: absolute;
            top: 1rem;
            right: 1rem;
            background: none;
            border: none;
            color: white;
            font-size: 1.5rem;
            cursor: pointer;
        }
        
        .game-history-body {
            padding: 1.5rem;
        }
        
        .history-section {
            margin-bottom: 2rem;
        }
        
        .history-section h3 {
            color: #2c3e50;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .history-section-icon {
            font-size: 1.2rem;
        }
        
        .play-history-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            border-left: 4px solid #3498db;
        }
        
        .play-history-date {
            font-weight: 600;
            color: #2c3e50;
            margin-bottom: 0.5rem;
        }
        
        .play-history-details {
            font-size: 0.875rem;
            color: #7f8c8d;
            line-height: 1.5;
        }
        
        .travel-history-item {
            background: #f8f9fa;
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 1rem;
        }
        
        .travel-arrow {
            color: #3498db;
            font-size: 1.5rem;
        }
        
        .travel-location {
            flex: 1;
        }
        
        .travel-location-name {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .travel-date {
            font-size: 0.875rem;
            color: #7f8c8d;
        }
        
        .game-stats-summary {
            background: #e8f4f8;
            padding: 1.5rem;
            border-radius: 8px;
            margin-bottom: 1.5rem;
        }
        
        .game-stats-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 0.5rem;
        }
        
        .game-stats-label {
            color: #7f8c8d;
        }
        
        .game-stats-value {
            font-weight: 600;
            color: #2c3e50;
        }
        
        .no-history {
            text-align: center;
            color: #7f8c8d;
            padding: 2rem;
        }
        
        .history-actions {
            display: flex;
            gap: 0.5rem;
            margin-top: 1.5rem;
            padding-top: 1.5rem;
            border-top: 1px solid #ecf0f1;
        }
        
        @media (max-width: 600px) {
            .mode-selector {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .stats-grid {
                grid-template-columns: 1fr;
            }
            
            .game-history-content {
                margin: 0.5rem;
            }
        }

        /* Trade/Sell indicators */
        .trade-indicator {
            display: inline-block;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
            font-weight: 600;
            margin-left: 0.5rem;
        }

        .trade-indicator.trade {
            background: #f39c12;
            color: white;
        }

        .trade-indicator.sell {
            background: #27ae60;
            color: white;
        }

        /* Value display styling */
        .value-display {
            font-weight: 600;
            color: #27ae60;
        }

        .value-outdated {
            color: #7f8c8d;
            font-style: italic;
        }

        /* Market data styling */
        .market-info {
            font-size: 0.875rem;
            color: #7f8c8d;
            margin-top: 0.25rem;
        }


    </style>
</head>
<body>
    <header>
        <h1>üé≤ BoardGame Collection Manager</h1>
    </header>
    
    <main>
        <div class="mode-selector">
            <button class="mode-btn active" onclick="setMode('view')">
                <span class="icon">üì¶</span>
                <span>View Bin</span>
            </button>
            <button class="mode-btn" onclick="setMode('history')">
                <span class="icon">üìö</span>
                <span>Game History</span>
            </button>
            <button class="mode-btn" onclick="setMode('search')">
                <span class="icon">üîç</span>
                <span>Search</span>
            </button>
            <button class="mode-btn" onclick="setMode('play')">
                <span class="icon">üéÆ</span>
                <span>Log Play</span>
            </button>
            <button class="mode-btn" onclick="setMode('checkout')">
                <span class="icon">üì§</span>
                <span>Check Out</span>
            </button>
            <button class="mode-btn" onclick="setMode('checkin')">
                <span class="icon">üì•</span>
                <span>Check In</span>
            </button>
            <button class="mode-btn" onclick="setMode('stats')">
                <span class="icon">üìä</span>
                <span>Stats</span>
            </button>
            <button class="mode-btn" onclick="setMode('players')">
                <span class="icon">üë•</span>
                <span>Players</span>
            </button>
            <button class="mode-btn" onclick="setMode('sessions')">
                <span class="icon">üéØ</span>
                <span>Sessions</span>
            </button>
            <button class="mode-btn" onclick="setMode('bulk')">
                <span class="icon">üìã</span>
                <span>Bulk Ops</span>
            </button>
            <button class="mode-btn" onclick="setMode('bgg')">
                <span class="icon">üåê</span>
                <span>BGG Import</span>
            </button>
            <button class="mode-btn" onclick="setMode('settings')">
                <span class="icon">‚öôÔ∏è</span>
                <span>Settings</span>
            </button>
        </div>
        
        <!-- Scan Section -->
        <div id="scan-section" class="scan-container hidden">
            <div id="reader"></div>
            <div class="action-buttons">
                <button class="btn btn-primary" onclick="startScanning()">Start Scanning</button>
                <button class="btn btn-secondary" onclick="stopScanning()">Stop</button>
            </div>
            <div style="margin-top: 1rem; padding-top: 1rem; border-top: 1px solid #ecf0f1;">
                <p style="text-align: center; color: #7f8c8d; margin-bottom: 0.5rem;">Or enter QR code manually:</p>
                <input type="text" id="manual-qr-input" placeholder="Enter QR code text (e.g., BIN:001)" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 6px;" onkeypress="if(event.key==='Enter')processManualQR()">
                <button class="btn btn-primary" onclick="processManualQR()" style="margin-top: 0.5rem; width: 100%;">Process Manual Entry</button>
            </div>
        </div>
        
        <!-- Enhanced Play Logging Section -->
        <div id="play-log-section" class="setup-section hidden">
            <h3>üéÆ Log Game Play</h3>
            <p id="play-game-info" style="margin-bottom: 1rem;"></p>
            
            <div style="margin-bottom: 1rem;">
                <label style="font-weight: 600; display: block; margin-bottom: 0.5rem;">Players (comma-separated)</label>
                <input type="text" id="play-players" placeholder="e.g., Alice, Bob, Charlie">
            </div>
            
            <div style="margin-bottom: 1rem;">
                <label style="font-weight: 600; display: block; margin-bottom: 0.5rem;">Winner</label>
                <input type="text" id="play-winner" placeholder="Enter winner's name">
            </div>
            
            <div style="margin-bottom: 1rem;">
                <label style="font-weight: 600; display: block; margin-bottom: 0.5rem;">Game Rating</label>
                <div class="rating-input" id="play-rating">
                    <span class="star" data-rating="1">‚òÜ</span>
                    <span class="star" data-rating="2">‚òÜ</span>
                    <span class="star" data-rating="3">‚òÜ</span>
                    <span class="star" data-rating="4">‚òÜ</span>
                    <span class="star" data-rating="5">‚òÜ</span>
                </div>
            </div>
            
            <div style="margin-bottom: 1rem;">
                <label style="font-weight: 600; display: block; margin-bottom: 0.5rem;">Session Template</label>
                <select id="play-session-template">
                    <option value="">No template</option>
                </select>
            </div>
            
            <div style="margin-bottom: 1rem;">
                <label style="font-weight: 600; display: block; margin-bottom: 0.5rem;">Notes</label>
                <textarea id="play-notes" rows="3" style="width: 100%; padding: 0.5rem; border: 1px solid #ddd; border-radius: 6px;"></textarea>
            </div>
            
            <button class="btn btn-primary" onclick="confirmLogPlay()" style="width: 100%;">Log Play</button>
            <button class="btn btn-secondary" onclick="cancelLogPlay()" style="width: 100%; margin-top: 0.5rem;">Cancel</button>
        </div>
        
        <!-- Search Section -->
        <div id="search-section" class="search-container hidden">
            <input type="text" id="search-input" class="search-input" placeholder="Search games by title, ID, or BGG ID..." onkeyup="performSearch()">
            <div class="tabs" style="margin-top: 1rem;">
                <button class="tab active" onclick="setSearchTab('all')">All Games</button>
                <button class="tab" onclick="setSearchTab('available')">Available</button>
                <button class="tab" onclick="setSearchTab('checked-out')">Checked Out</button>
            </div>
        </div>
        
        <!-- Advanced Stats Section -->
        <div id="stats-section" class="hidden">
            <div class="tabs">
                <button class="tab active" onclick="setStatsTab('overview')">Overview</button>
                <button class="tab" onclick="setStatsTab('trends')">Play Trends</button>
                <button class="tab" onclick="setStatsTab('ratings')">Ratings</button>
                <button class="tab" onclick="setStatsTab('sessions')">Session Analysis</button>
                <button class="tab" onclick="setStatsTab('value')">Collection Value</button>
            </div>
            
            <div id="stats-overview" class="stats-content">
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value" id="total-games">0</div>
                        <div class="stat-label">Total Games</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="total-plays">0</div>
                        <div class="stat-label">Total Plays</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="unique-played">0</div>
                        <div class="stat-label">Games Played</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avg-players">0</div>
                        <div class="stat-label">Avg Players/Game</div>
                    </div>
                </div>
                <div class="results">
                    <h3>Most Played Games</h3>
                    <div id="most-played-list"></div>
                </div>
                <div class="results" style="margin-top: 1rem;">
                    <h3>Never Played Games</h3>
                    <div id="never-played-list"></div>
                </div>
            </div>
            
            <div id="stats-trends" class="stats-content hidden">
                <div class="chart-container">
                    <canvas id="trends-chart"></canvas>
                </div>
                <div style="margin-top: 1rem;">
                    <label>Time Period:</label>
                    <select id="trends-period" onchange="updateTrendsChart()">
                        <option value="week">Last Week</option>
                        <option value="month" selected>Last Month</option>
                        <option value="quarter">Last Quarter</option>
                        <option value="year">Last Year</option>
                    </select>
                </div>
            </div>
            
            <div id="stats-ratings" class="stats-content hidden">
                <div class="results">
                    <h3>Top Rated Games</h3>
                    <div id="top-rated-list"></div>
                </div>
                <div class="chart-container" style="margin-top: 2rem;">
                    <canvas id="ratings-distribution"></canvas>
                </div>
            </div>
            
            <div id="stats-sessions" class="stats-content hidden">
                <div class="results">
                    <h3>Game Night Analysis</h3>
                    <div id="session-stats"></div>
                </div>
                <div class="chart-container" style="margin-top: 2rem;">
                    <canvas id="session-chart"></canvas>
                </div>
            </div>
            <div id="stats-value" class="stats-content hidden">
                <div class="setup-section">
                    <h3>üìä Collection Valuation via Geek Group</h3>
                    
                    <div style="margin-bottom: 1.5rem;">
                        <p style="margin-bottom: 1rem;">Geek Group provides advanced collection analytics and valuation for your BoardGameGeek collection.</p>
                        
                        <label style="display: block; margin-bottom: 0.5rem; font-weight: 600;">Your BGG Username:</label>
                        <input type="text" id="geekgroup-username" placeholder="Enter your BGG username" 
                               style="width: 100%; padding: 0.75rem; border: 1px solid #ddd; border-radius: 6px; margin-bottom: 1rem;">
                        
                        <button class="btn btn-primary" onclick="openGeekGroup()" style="width: 100%; margin-bottom: 0.5rem;">
                            üöÄ View Collection on Geek Group
                        </button>
                        
                        <button class="btn btn-info" onclick="saveGeekGroupUsername()" style="width: 100%;">
                            üíæ Save Username
                        </button>
                    </div>
                    
                    <div class="setup-instructions">
                        <h4>How to use Geek Group:</h4>
                        <ol>
                            <li>Enter your BoardGameGeek username above</li>
                            <li>Click "View Collection on Geek Group"</li>
                            <li>Geek Group will analyze your BGG collection and provide:
                                <ul>
                                    <li>Current market valuations</li>
                                    <li>Collection statistics</li>
                                    <li>Price trends</li>
                                    <li>Rarity analysis</li>
                                </ul>
                            </li>
                            <li>Bookmark your Geek Group page for quick access</li>
                        </ol>
                    </div>
                    
                    <div id="geekgroup-iframe-container" style="margin-top: 2rem; display: none;">
                        <h4>Geek Group Collection View</h4>
                        <iframe id="geekgroup-iframe" src="" style="width: 100%; height: 600px; border: 1px solid #ddd; border-radius: 8px;"></iframe>
                    </div>
                </div>
            </div>
        
        <!-- Players Section -->
        <div id="players-section" class="hidden">
            <div class="tabs">
                <button class="tab active" onclick="setPlayerTab('manage')">Manage Players</button>
                <button class="tab" onclick="setPlayerTab('stats')">Statistics</button>
                <button class="tab" onclick="setPlayerTab('compare')">Compare</button>
                <button class="tab" onclick="setPlayerTab('history')">Session History</button>
            </div>
            
            <!-- Manage Players Tab -->
            <div id="player-manage" class="player-tab-content">
                <div class="setup-section">
                    <h3>Add New Player</h3>
                    <div style="display: flex; gap: 0.5rem; margin-bottom: 1rem;">
                        <input type="text" id="new-player-name" placeholder="Player name" style="flex: 1;">
                        <input type="email" id="new-player-email" placeholder="Email (optional)" style="flex: 1;">
                        <button class="btn btn-primary" onclick="addNewPlayer()">Add Player</button>
                    </div>
                </div>
                
                <div class="results">
                    <h3>All Players</h3>
                    <div id="all-players-list"></div>
                </div>
            </div>
            
            <!-- Statistics Tab -->
            <div id="player-stats" class="player-tab-content hidden">
                <div class="search-container">
                    <h3>Player Statistics</h3>
                    <p style="margin: 1rem 0;">Click on a player to see detailed statistics:</p>
                    <div class="player-select" id="player-stats-list"></div>
                </div>
                <div id="individual-player-stats"></div>
            </div>
            
            <!-- Compare Tab -->
            <div id="player-compare" class="player-tab-content hidden">
                <div class="search-container">
                    <h3>Compare Players</h3>
                    <p style="margin: 1rem 0;">Select 2 or more players to compare:</p>
                    <div class="player-select" id="player-compare-list"></div>
                </div>
                
                <div id="player-comparison" class="hidden">
                    <div class="results">
                        <h3>Head-to-Head Comparison</h3>
                        <div id="h2h-stats"></div>
                    </div>
                    
                    <div class="chart-container" style="margin-top: 2rem;">
                        <canvas id="player-comparison-chart"></canvas>
                    </div>
                </div>
            </div>
            
            <!-- Session History Tab -->
            <div id="player-history" class="player-tab-content hidden">
                <div class="search-container">
                    <h3>Player Session History</h3>
                    <select id="player-history-select" onchange="loadPlayerSessionHistory()" style="width: 100%; padding: 0.75rem; margin: 1rem 0;">
                        <option value="">Select a player...</option>
                    </select>
                </div>
                <div id="player-session-history"></div>
            </div>
        </div>
        
        <!-- Sessions Section -->
        <div id="sessions-section" class="setup-section hidden">
            <h3>üéØ Session Templates</h3>
            
            <div style="margin-bottom: 2rem;">
                <h4>Create New Template</h4>
                <input type="text" id="template-name" placeholder="Template name (e.g., Friday Night Group)">
                <input type="text" id="template-players" placeholder="Regular players (comma-separated)" style="margin-top: 0.5rem;">
                <textarea id="template-notes" placeholder="Notes about this group" rows="2" style="width: 100%; margin-top: 0.5rem; padding: 0.5rem; border: 1px solid #ddd; border-radius: 6px;"></textarea>
                <button class="btn btn-primary" onclick="createSessionTemplate()" style="margin-top: 0.5rem;">Create Template</button>
            </div>
            
            <div>
                <h4>Existing Templates</h4>
                <div id="session-templates-list"></div>
            </div>
        </div>
        
        <!-- Bulk Operations Section -->
        <div id="bulk-section" class="hidden">
            <div class="search-container">
                <h3>Select Games for Bulk Operations</h3>
                <div style="margin-top: 1rem;">
                    <button class="btn btn-primary" onclick="selectAllGames()">Select All</button>
                    <button class="btn btn-secondary" onclick="deselectAllGames()">Deselect All</button>
                </div>
            </div>
            <div id="bulk-actions" class="bulk-actions hidden">
                <span id="selected-count">0 games selected</span>
                <select id="bulk-bin-select" style="flex: 1;">
                    <option value="">Select destination bin...</option>
                </select>
                <button class="btn btn-primary" onclick="bulkMove()">Move to Bin</button>
                <button class="btn btn-secondary" onclick="bulkCheckout()">Check Out All</button>
            </div>
        </div>
        
        <!-- BGG Import Section -->
        <div id="bgg-section" class="setup-section hidden">
            <h3>üåê BoardGameGeek Import</h3>
            <input type="text" id="bgg-search" placeholder="Search BoardGameGeek for a game..." onkeypress="if(event.key==='Enter')searchBGG()">
            <button class="btn btn-primary" onclick="searchBGG()" style="margin-top: 0.5rem;">Search BGG</button>
            
            <div style="margin-top: 1rem;">
                <h4>Or Import from BGG Collection</h4>
                <input type="text" id="bgg-username" placeholder="BGG Username">
                <button class="btn btn-primary" onclick="importBGGCollection()" style="margin-top: 0.5rem;">Import Collection</button>
            </div>
            
            <div id="bgg-results" class="results hidden" style="margin-top: 1rem;"></div>
        </div>
        
        <div id="workflow-state" class="workflow-state hidden"></div>
        
        <div id="status-message" class="hidden"></div>
        
        <div id="results" class="results hidden">
            <h3>Results</h3>
            <div id="results-content"></div>
        </div>
        
        <!-- Settings Section -->
        <div id="settings-section" class="setup-section hidden">
            <h3>‚öôÔ∏è Google Sheets Setup</h3>
            <input type="text" id="spreadsheet-id" placeholder="Google Spreadsheet ID" />
            <input type="text" id="api-key" placeholder="Google API Key" />
            <button class="btn btn-primary" onclick="saveSettings()">Save Settings</button>
            
            <div style="margin-top: 1rem;">
                <h4>üì∏ Photo Storage Settings</h4>
                <input type="text" id="photo-folder-id" placeholder="Google Drive Folder ID for Photos" />
                <button class="btn btn-primary" onclick="savePhotoSettings()">Save Photo Settings</button>
            </div>
            
            <div class="setup-instructions">
                <strong>Enhanced Sheet Setup:</strong><br>
                Your PlayLog sheet now needs these columns:<br>
                A: Timestamp<br>
                B: Game ID<br>
                C: Players (comma-separated)<br>
                D: Notes<br>
                E: Winner<br>
                F: Rating (1-5)<br>
                G: Session ID (optional)<br><br>
                
                <strong>Players Sheet Setup:</strong><br>
                Create a sheet called "Players" with these columns:<br>
                A: Player ID<br>
                B: Name<br>
                C: Email (optional)<br><br>
                
                <strong>Session Templates Sheet (optional):</strong><br>
                Create a new sheet called "SessionTemplates" with:<br>
                A: Template ID<br>
                B: Template Name<br>
                C: Regular Players<br>
                D: Notes<br><br>
                
                <strong>Travel History Sheet (NEW):</strong><br>
                Create a sheet called "TravelHistory" with these columns:<br>
                A: Timestamp<br>
                B: Game ID<br>
                C: From Location<br>
                D: To Location<br>
                E: Action (CHECKOUT/CHECKIN/MOVE)<br><br>
                
                <strong>Note:</strong> The sheets will be created automatically when you use features if you have auto-update enabled.
            </div>
            
            <div class="status-success" style="margin-top: 1rem; display: none;" id="first-time-notice">
                <strong>üéâ First Time Setup Detected!</strong><br>
                Your credentials have been pre-filled. Click "Save Settings" to connect to your Google Sheet.
            </div>
            
            <div class="setup-section" style="margin-top: 1rem;">
                <h4>üöÄ Enable Automatic Updates (Optional)</h4>
                <input type="text" id="apps-script-url" placeholder="Google Apps Script Web App URL (optional)" style="margin-top: 1rem;" />
                <button class="btn btn-info" onclick="saveAppsScriptUrl()">Save Script URL</button>
            </div>
        </div>
    </main>
    
    <!-- Game History Modal -->
    <div id="game-history-modal" class="game-history-modal hidden">
        <div class="game-history-content">
            <div class="game-history-header">
                <h2 id="game-history-title">Game History</h2>
                <button class="game-history-close" onclick="closeGameHistory()">√ó</button>
            </div>
            <div class="game-history-body">
                <div id="game-stats-summary" class="game-stats-summary"></div>
                
                <div class="history-section">
                    <h3><span class="history-section-icon">üéÆ</span> Play History</h3>
                    <div id="game-play-history"></div>
                </div>
                
                <div class="history-section">
                    <h3><span class="history-section-icon">üìç</span> Travel History</h3>
                    <div id="game-travel-history"></div>
                </div>
                
                <div class="history-actions">
                    <button class="btn btn-primary" onclick="checkoutGameFromHistory()">Check Out</button>
                    <button class="btn btn-info" onclick="logPlayFromHistory()">Log Play</button>
                    <button class="btn btn-secondary" onclick="closeGameHistory()">Close</button>
                </div>
            </div>
        </div>
    </div>

   
    <script>
        // Global variables
        let html5QrcodeScanner = null;
        let currentMode = 'view';
        let searchTab = 'all';
        let statsTab = 'overview';
        let playerTab = 'manage';
        let selectedGames = new Set();
        let selectedPlayers = new Set();
        let allGames = [];
        let allBins = [];
        let allPlayers = [];
        let playHistory = [];
        let travelHistory = [];
        let sessionTemplates = [];
        let selectedPlayerForStats = null;
        let currentHistoryGameId = null;
        let currentHistoryGameInfo = null;
        let checkoutWorkflow = {
            gameId: null,
            gameTitle: null,
            binId: null,
            step: 'game' // 'game' or 'bin'
        };
        let currentPlayGame = null;
        let currentRating = 0;
        
        // Chart.js instances
        let trendsChart = null;
        let ratingsChart = null;
        let sessionChart = null;
        let playerComparisonChart = null;
        
        // Cache variables
        let gameCache = new Map();
        let cacheTimestamp = 0;
        const CACHE_DURATION = 5 * 60 * 1000; // 5 minutes
        
        // Google Sheets API base URL
        const SHEETS_API_BASE = 'https://sheets.googleapis.com/v4/spreadsheets';
        
        // BoardGameGeek API (via CORS proxy)
        const BGG_API_BASE = 'https://api.geekdo.com/xmlapi2';
        const CORS_PROXY = 'https://corsproxy.io/?';
        
        // Initialize on load
        window.onload = function() {
            loadSettings();
            initializeRatingStars();
            
            // Check if QR library loaded
            if (typeof Html5Qrcode === 'undefined') {
                console.error('Html5Qrcode library failed to load');
                showStatus('Warning: QR scanner not available. Use manual entry.', 'error');
            } else {
                console.log('QR scanner library loaded successfully');
            }
            
            // Set initial mode without triggering camera
            currentMode = 'view';
            document.querySelectorAll('.mode-btn').forEach(btn => {
                if (btn.querySelector('span:last-child').textContent === 'View Bin') {
                    btn.classList.add('active');
                }
            });
            
            // Ensure modal is hidden
            document.getElementById('game-history-modal').classList.add('hidden');
            
            // Add click handler to modal background to close when clicking outside
            document.getElementById('game-history-modal').addEventListener('click', function(e) {
                if (e.target === this) {
                    closeGameHistory();
                }
            });
        };
        
        // Initialize rating stars interaction
        function initializeRatingStars() {
            document.querySelectorAll('.star').forEach(star => {
                star.addEventListener('click', function() {
                    const rating = parseInt(this.dataset.rating);
                    setRating(rating);
                });
                star.addEventListener('mouseover', function() {
                    const rating = parseInt(this.dataset.rating);
                    highlightStars(rating);
                });
            });
            
            document.getElementById('play-rating').addEventListener('mouseleave', function() {
                highlightStars(currentRating);
            });
        }
        
        function setRating(rating) {
            currentRating = rating;
            highlightStars(rating);
        }
        
        function highlightStars(rating) {
            document.querySelectorAll('.star').forEach((star, index) => {
                if (index < rating) {
                    star.textContent = '‚òÖ';
                    star.classList.add('filled');
                } else {
                    star.textContent = '‚òÜ';
                    star.classList.remove('filled');
                }
            });
        }
        
        // Mode management
        function setMode(mode) {
            try {
                console.log('Setting mode to:', mode);
                
                // Check if settings are configured for modes that need them
                const needsSettings = ['search', 'players', 'sessions', 'bulk', 'stats', 'play', 'checkout', 'checkin', 'history'];
                if (needsSettings.includes(mode) && mode !== 'settings') {  // Don't check settings for settings mode!
                    const spreadsheetId = localStorage.getItem('spreadsheetId');
                    const apiKey = localStorage.getItem('apiKey');
                    
                    if (!spreadsheetId || !apiKey) {
                        showStatus('Please configure Google Sheets settings first!', 'error');
                        setMode('settings');  // Redirect to settings
                        return;
                    }
                }
                
                currentMode = mode;
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                // Find the button that was clicked and make it active
                document.querySelectorAll('.mode-btn').forEach(btn => {
                    if (btn.querySelector('span:last-child').textContent === 
                        (mode === 'view' ? 'View Bin' :
                         mode === 'history' ? 'Game History' :
                         mode === 'search' ? 'Search' :
                         mode === 'play' ? 'Log Play' :
                         mode === 'checkout' ? 'Check Out' :
                         mode === 'checkin' ? 'Check In' :
                         mode === 'stats' ? 'Stats' :
                         mode === 'players' ? 'Players' :
                         mode === 'sessions' ? 'Sessions' :
                         mode === 'bulk' ? 'Bulk Ops' :
                         mode === 'bgg' ? 'BGG Import' :
                         mode === 'settings' ? 'Settings' : '')) {
                        btn.classList.add('active');
                    }
                });
                
                // Reset workflow state
                checkoutWorkflow = { gameId: null, gameTitle: null, binId: null, step: 'game' };
                hideWorkflowState();
                hideStatus();
                hideResults();
                
                // Stop any active scanning
                if (html5QrcodeScanner) {
                    stopScanning();
                }
                
                // Hide all sections
                console.log('Hiding all sections...');
                document.getElementById('scan-section').classList.add('hidden');
                document.getElementById('play-log-section').classList.add('hidden');
                document.getElementById('search-section').classList.add('hidden');
                document.getElementById('stats-section').classList.add('hidden');
                document.getElementById('players-section').classList.add('hidden');
                document.getElementById('sessions-section').classList.add('hidden');
                document.getElementById('bulk-section').classList.add('hidden');
                document.getElementById('bgg-section').classList.add('hidden');
                document.getElementById('settings-section').classList.add('hidden');
                
                // Preload game data for modes that need it
                if (['play', 'checkout', 'checkin', 'search', 'bulk', 'history'].includes(mode)) {
                    console.log('Preloading game data for mode:', mode);
                    loadAllGames().catch(err => console.log('Preload error:', err));
                }
                
                // Show relevant sections
                console.log('Showing section for mode:', mode);
                switch(mode) {
                    case 'view':
                        document.getElementById('scan-section').classList.remove('hidden');
                        updateUIForMode();
                        break;
                        
                    case 'history':
                        document.getElementById('scan-section').classList.remove('hidden');
                        updateUIForMode();
                        break;
                        
                    case 'play':
                        document.getElementById('scan-section').classList.remove('hidden');
                        updateUIForMode();
                        break;
                        
                    case 'search':
                        console.log('Showing search section');
                        document.getElementById('search-section').classList.remove('hidden');
                        searchTab = 'all'; // Ensure we start with 'all' tab
                        
                        // Set the "All Games" tab as active
                        document.querySelectorAll('#search-section .tab').forEach(t => {
                            t.classList.remove('active');
                            if (t.textContent === 'All Games') {
                                t.classList.add('active');
                            }
                        });
                        
                        // Load and display all games
                        loadAllGames().then(() => {
                            console.log('Games loaded, performing search');
                            performSearch(); // This will display all games
                        }).catch(err => {
                            console.error('Error loading games for search:', err);
                            showStatus('Error loading games: ' + err.message, 'error');
                        });
                        break;
                        
                    case 'stats':
                        console.log('Showing stats section');
                        document.getElementById('stats-section').classList.remove('hidden');
                        loadStatistics().catch(err => {
                            console.error('Error loading statistics:', err);
                            showStatus('Error loading statistics: ' + err.message, 'error');
                        });
                        break;
                        
                    case 'players':
                        console.log('Showing players section');
                        document.getElementById('players-section').classList.remove('hidden');
                        loadPlayerStats().catch(err => {
                            console.error('Error loading player stats:', err);
                            showStatus('Error loading players: ' + err.message, 'error');
                        });
                        break;
                        
                    case 'sessions':
                        console.log('Showing sessions section');
                        document.getElementById('sessions-section').classList.remove('hidden');
                        loadSessionTemplates().catch(error => {
                            console.error('Error loading session templates:', error);
                            showStatus('Error loading sessions: ' + error.message, 'error');
                        });
                        break;
                        
                    case 'bulk':
                        console.log('Showing bulk section');
                        document.getElementById('bulk-section').classList.remove('hidden');
                        loadBulkOperations().catch(err => {
                            console.error('Error loading bulk operations:', err);
                            showStatus('Error loading bulk operations: ' + err.message, 'error');
                        });
                        break;
                        
                    case 'bgg':
                        console.log('Showing BGG section');
                        document.getElementById('bgg-section').classList.remove('hidden');
                        // Clear any previous results
                        document.getElementById('bgg-results').classList.add('hidden');
                        break;
                        
                    case 'settings':
                        console.log('Showing settings section');
                        document.getElementById('settings-section').classList.remove('hidden');
                        // Make sure all sections are visible
                        document.querySelectorAll('#settings-section .setup-section').forEach(section => {
                            section.style.display = 'block';
                        });
                        break;
                        
                    case 'checkout':
                    case 'checkin':
                        document.getElementById('scan-section').classList.remove('hidden');
                        updateUIForMode();
                        break;
                        
                    default:
                        console.error('Unknown mode:', mode);
                        showStatus('Unknown mode selected', 'error');
                }
                
                // Scroll to top to ensure the section is visible
                window.scrollTo(0, 0);
                document.querySelector('main').scrollTo(0, 0);
                
                console.log('Mode change complete');
                
                // Debug: Check what's actually visible right now
                const visibleSection = document.querySelector('main > div:not(.hidden):not(.mode-selector)');
                if (visibleSection) {
                    console.log('Visible section:', visibleSection.id);
                } else {
                    console.log('WARNING: No visible section found!');
                }
                
            } catch (error) {
                console.error('Error in setMode:', error);
                showStatus('Error switching modes: ' + error.message, 'error');
            }
        }
        
        function updateUIForMode() {
            if (currentMode === 'view') {
                showWorkflowState('Scan a bin QR code to view contents');
            } else if (currentMode === 'checkout') {
                showWorkflowState('Step 1: Scan the game QR code');
            } else if (currentMode === 'checkin') {
                showWorkflowState('Step 1: Scan the game QR code');
            } else if (currentMode === 'play') {
                showWorkflowState('Scan a game QR code to log a play');
            } else if (currentMode === 'history') {
                showWorkflowState('Scan a game QR code to view its history');
            }
            // Don't automatically start scanning
        }
        
        // Game History Functions
        async function handleGameHistory(data) {
            if (data.type !== 'GAME') {
                showStatus('Please scan a game QR code', 'error');
                // Restart scanner
                setTimeout(() => startScanning(), 2000);
                return;
            }
            
            try {
                showStatus('Loading game history...', 'success');
                
                // Load all necessary data
                const [gameInfo, plays, travels] = await Promise.all([
                    getGameInfo(data.id),
                    loadEnhancedPlayHistory(),
                    loadTravelHistory()
                ]);
                
                if (!gameInfo) {
                    showStatus('Game not found in inventory', 'error');
                    setTimeout(() => startScanning(), 2000);
                    return;
                }
                
                // Store current game info
                currentHistoryGameId = data.id;
                currentHistoryGameInfo = gameInfo;
                
                // Display the history modal
                displayGameHistory(gameInfo, plays, travels);
                
            } catch (error) {
                showStatus('Error loading game history: ' + error.message, 'error');
                setTimeout(() => startScanning(), 3000);
            }
        }
        
        function displayGameHistory(gameInfo, allPlays, allTravels) {
                // Make sure we have valid game info
                if (!gameInfo) {
                    console.error('No game info provided to displayGameHistory');
                    return;
                }
                
                // Filter plays and travels for this game
                const gamePlays = allPlays.filter(play => play.gameId === gameInfo.id);
                const gameTravels = allTravels.filter(travel => travel.gameId === gameInfo.id);
                
                // Ensure all containers exist and are clear
                const summaryDiv = document.getElementById('game-stats-summary');
                const playHistoryDiv = document.getElementById('game-play-history');
                const travelHistoryDiv = document.getElementById('game-travel-history');
                
                if (!summaryDiv || !playHistoryDiv || !travelHistoryDiv) {
                    console.error('Game history modal elements not found');
                    return;
                }
                
                // Calculate statistics
                const stats = calculateGameStatistics(gamePlays);
                
                // Update modal header
                document.getElementById('game-history-title').textContent = gameInfo.title;
                
                // Display statistics summary
                const statsHtml = `
                    <div class="game-stats-row">
                        <span class="game-stats-label">Total Plays:</span>
                        <span class="game-stats-value">${stats.totalPlays}</span>
                    </div>
                    <div class="game-stats-row">
                        <span class="game-stats-label">Average Rating:</span>
                        <span class="game-stats-value">${stats.avgRating ? stats.avgRating.toFixed(1) + '/5' : 'No ratings'}</span>
                    </div>
                    <div class="game-stats-row">
                        <span class="game-stats-label">Most Frequent Winner:</span>
                        <span class="game-stats-value">${stats.topWinner || 'No winner data'}</span>
                    </div>
                    <div class="game-stats-row">
                        <span class="game-stats-label">Average Player Count:</span>
                        <span class="game-stats-value">${stats.avgPlayers ? stats.avgPlayers.toFixed(1) : 'Unknown'}</span>
                    </div>
                    <div class="game-stats-row">
                        <span class="game-stats-label">Current Location:</span>
                        <span class="game-stats-value">${formatLocation(gameInfo.location)}</span>
                    </div>
                    <div class="game-stats-row">
                        <span class="game-stats-label">Last Played:</span>
                        <span class="game-stats-value">${stats.lastPlayed || 'Never'}</span>
                    </div>
                `;
                summaryDiv.innerHTML = statsHtml;
                
                // Display play history
                if (gamePlays.length === 0) {
                    playHistoryDiv.innerHTML = '<div class="no-history">No plays recorded yet</div>';
                } else {
                    playHistoryDiv.innerHTML = gamePlays
                        .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp))
                        .slice(0, 10) // Show last 10 plays
                        .map(play => {
                            const date = new Date(play.timestamp);
                            let details = [];
                            
                            if (play.players) details.push(`Players: ${play.players}`);
                            if (play.winner) details.push(`Winner: ${play.winner}`);
                            if (play.rating) details.push(`Rating: ${getStarDisplay(play.rating)}`);
                            if (play.notes) details.push(`Notes: ${play.notes}`);
                            
                            return `
                                <div class="play-history-item">
                                    <div class="play-history-date">${date.toLocaleDateString()} ${date.toLocaleTimeString()}</div>
                                    <div class="play-history-details">${details.join('<br>')}</div>
                                </div>
                            `;
                        }).join('');
                        
                    if (gamePlays.length > 10) {
                        playHistoryDiv.innerHTML += `<p style="text-align: center; color: #7f8c8d; margin-top: 1rem;">...and ${gamePlays.length - 10} more plays</p>`;
                    }
                }
                
                // Display travel history
                if (gameTravels.length === 0) {
                    travelHistoryDiv.innerHTML = '<div class="no-history">No location changes recorded yet</div>';
                } else {
                    // Get current location as most recent
                    const travelItems = [{
                        timestamp: new Date().toISOString(),
                        toLocation: gameInfo.location,
                        action: 'CURRENT'
                    }];
                    
                    // Add historical travels
                    travelItems.push(...gameTravels.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp)));
                    
                    travelHistoryDiv.innerHTML = travelItems
                        .slice(0, 10)
                        .map((travel, index) => {
                            const date = new Date(travel.timestamp);
                            const isCurrentLocation = travel.action === 'CURRENT';
                            
                            return `
                                <div class="travel-history-item">
                                    <div class="travel-location">
                                        <div class="travel-location-name">${formatLocation(travel.toLocation)}</div>
                                        <div class="travel-date">
                                            ${isCurrentLocation ? 'Current Location' : 
                                              travel.action === 'CHECKOUT' ? 'Checked out on ' + date.toLocaleDateString() :
                                              travel.action === 'CHECKIN' ? 'Checked in on ' + date.toLocaleDateString() :
                                              'Moved on ' + date.toLocaleDateString()}
                                        </div>
                                    </div>
                                    ${index < travelItems.length - 1 ? '<div class="travel-arrow">‚Üì</div>' : ''}
                                </div>
                            `;
                        }).join('');
                        
                    if (gameTravels.length > 9) {
                        travelHistoryDiv.innerHTML += `<p style="text-align: center; color: #7f8c8d; margin-top: 1rem;">...and ${gameTravels.length - 9} more location changes</p>`;
                    }
                }
                                
                // Update action buttons to include trade/sell toggle
                const actionsHtml = `
                    <button class="btn btn-primary" onclick="checkoutGameFromHistory()">Check Out</button>
                    <button class="btn btn-info" onclick="logPlayFromHistory()">Log Play</button>
                    ${gameInfo.bggId ? `
                        <button class="btn btn-info" onclick="window.open('https://boardgamegeek.com/geekmarket/browse?objecttype=thing&objectid=${gameInfo.bggId}', '_blank')">
                            üõí Check Geek Market
                        </button>
                    ` : ''}
                    <button class="btn btn-info" onclick="openManualValueModal('${gameInfo.id}', '${gameInfo.title.replace(/'/g, "\\'")}')">
                        üí∞ Enter Value
                    </button>
                    <button class="btn btn-secondary" onclick="closeGameHistory()">Close</button>
                `;
            
            // Replace the history-actions div content
            document.querySelector('.history-actions').innerHTML = actionsHtml;
            
            // If BGG ID exists and value is old or missing, fetch fresh value
            if (gameInfo.bggId && (!gameInfo.valueUpdated || 
                (new Date() - new Date(gameInfo.valueUpdated)) > 24 * 60 * 60 * 1000)) {
                refreshGameValue(gameInfo.id);
            }

            // Show the modal
            document.getElementById('game-history-modal').classList.remove('hidden');
        }

        // Helper functions for trade status display
        function getTradeStatusDisplay(status) {
            if (status === 'TRADE') return '<span style="color: #f39c12;">üîÑ Available for Trade</span>';
            if (status === 'SELL') return '<span style="color: #27ae60;">üí∞ For Sale</span>';
            return '<span style="color: #7f8c8d;">Not for trade/sale</span>';
        }

        function getTradeButtonText(status) {
            if (status === 'TRADE') return 'Mark for Sale';
            if (status === 'SELL') return 'Remove from Trade/Sale';
            return 'Mark for Trade';
        }

       // Refresh game value from BGG
        async function refreshGameValue(gameId) {
            const gameInfo = await getGameInfo(gameId);
            if (!gameInfo || !gameInfo.bggId) {
                showStatus('Cannot fetch value - no BGG ID', 'error');
                return;
            }
            
            showStatus('Fetching current market value...', 'success');
            
            // Check if we're in the game history modal
            const marketValueElement = document.getElementById('game-market-value');
            if (marketValueElement) {
                marketValueElement.innerHTML = 'Loading...';
            }
            
            const marketData = await fetchBGGMarketValue(gameInfo.bggId);
            if (marketData && marketData.value > 0) {
                const historicalHigh = Math.max(marketData.value, gameInfo.historicalHigh || 0);
                const historicalLow = gameInfo.historicalLow > 0 ? 
                    Math.min(marketData.value, gameInfo.historicalLow) : marketData.value;
                
                await updateGameValue(gameId, marketData.value, historicalHigh, historicalLow);
                
                // Only update the modal element if it exists
                if (marketValueElement) {
                    marketValueElement.innerHTML = `
                        $${marketData.value.toFixed(2)} 
                        <small style="color: #7f8c8d;">(${marketData.listings} listings, 
                        $${marketData.lowest.toFixed(2)}-$${marketData.highest.toFixed(2)})</small>
                    `;
                }
                
                showStatus('Value updated successfully!', 'success');
                
                // Return the market data so calling functions can use it
                return marketData;
            } else {
                // Only update the modal element if it exists
                if (marketValueElement) {
                    marketValueElement.innerHTML = 'No market data available';
                }
                showStatus('No active marketplace listings found', 'error');
                return null;
            }
        }

        // Toggle trade status from game history
        async function toggleGameTradeStatus(gameId) {
            const result = await toggleTradeStatus(gameId);
            if (result !== false) {
                // Update the display
                document.getElementById('trade-status-display').innerHTML = getTradeStatusDisplay(result);
                document.getElementById('trade-status-btn').textContent = getTradeButtonText(result);
                document.getElementById('trade-status-btn').className = 
                    `btn ${result === 'TRADE' ? 'btn-secondary' : 'btn-info'}`;
                
                showStatus(`Game marked as: ${result || 'Not for trade/sale'}`, 'success');
                
                // Update the cached game info
                if (currentHistoryGameInfo) {
                    currentHistoryGameInfo.tradeStatus = result;
                }
            }
        }
            
        function calculateGameStatistics(plays) {
            const stats = {
                totalPlays: plays.length,
                avgRating: null,
                topWinner: null,
                avgPlayers: null,
                lastPlayed: null
            };
            
            if (plays.length === 0) return stats;
            
            // Calculate average rating
            const ratings = plays.filter(p => p.rating).map(p => parseInt(p.rating));
            if (ratings.length > 0) {
                stats.avgRating = ratings.reduce((a, b) => a + b, 0) / ratings.length;
            }
            
            // Find most frequent winner
            const winners = {};
            plays.forEach(play => {
                if (play.winner) {
                    winners[play.winner] = (winners[play.winner] || 0) + 1;
                }
            });
            if (Object.keys(winners).length > 0) {
                const topWinnerEntry = Object.entries(winners).sort((a, b) => b[1] - a[1])[0];
                stats.topWinner = `${topWinnerEntry[0]} (${topWinnerEntry[1]} wins)`;
            }
            
            // Calculate average player count
            const playerCounts = plays
                .filter(p => p.players)
                .map(p => p.players.split(',').length);
            if (playerCounts.length > 0) {
                stats.avgPlayers = playerCounts.reduce((a, b) => a + b, 0) / playerCounts.length;
            }
            
            // Get last played date
            const sortedPlays = plays.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            if (sortedPlays.length > 0) {
                stats.lastPlayed = new Date(sortedPlays[0].timestamp).toLocaleDateString();
            }
            
            return stats;
        }
        
        function formatLocation(location) {
            if (location === 'CHECKED_OUT') return 'Checked Out';
            if (location === 'NEW') return 'New (No Bin)';
            if (location.length > 20 && !location.includes(':')) {
                return 'Bin ' + location.substring(0, 8) + '...';
            }
            return location;
        }
        
        function closeGameHistory() {
            document.getElementById('game-history-modal').classList.add('hidden');
            currentHistoryGameId = null;
            currentHistoryGameInfo = null;
            
            // If we're in history mode, update the workflow state
            if (currentMode === 'history') {
                showWorkflowState('Scan a game QR code to view its history');
            }
            // Don't automatically restart scanning
        }
        
        function checkoutGameFromHistory() {
            if (!currentHistoryGameInfo || !currentHistoryGameId) {
                showStatus('No game selected', 'error');
                return;
            }
            
            if (currentHistoryGameInfo.location !== 'CHECKED_OUT') {
                closeGameHistory();
                setMode('checkout');
                // Pre-fill the checkout workflow
                checkoutWorkflow.gameId = currentHistoryGameId;
                checkoutWorkflow.gameTitle = currentHistoryGameInfo.title;
                checkoutWorkflow.step = 'bin';
                showWorkflowState(`Step 2: Now scan the bin QR code you're taking "${currentHistoryGameInfo.title}" FROM`);
            } else {
                showStatus('This game is already checked out', 'error');
            }
        }
        
        function logPlayFromHistory() {
            if (!currentHistoryGameInfo || !currentHistoryGameId) {
                showStatus('No game selected', 'error');
                return;
            }
            
            if (currentHistoryGameInfo) {
                closeGameHistory();
                setMode('play');
                showPlayLogForm(currentHistoryGameInfo);
            }
        }
        
        // Travel History Functions
        async function loadTravelHistory() {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            if (!spreadsheetId || !apiKey) {
                console.log('No spreadsheet ID or API key found for loading travel history');
                return [];
            }
            
            try {
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/TravelHistory!A:E?key=${apiKey}`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const rows = data.values || [];
                    
                    travelHistory = [];
                    for (let i = 1; i < rows.length; i++) {
                        const [timestamp, gameId, fromLocation, toLocation, action] = rows[i];
                        travelHistory.push({
                            timestamp,
                            gameId,
                            fromLocation: fromLocation || '',
                            toLocation: toLocation || '',
                            action: action || 'MOVE'
                        });
                    }
                } else if (response.status === 400) {
                    // TravelHistory sheet doesn't exist yet
                    console.log('TravelHistory sheet not found, will be created when first location change is logged');
                    travelHistory = [];
                }
                
                console.log(`Loaded ${travelHistory.length} travel history entries`);
                return travelHistory;
            } catch (error) {
                console.error('Error loading travel history:', error);
                return [];
            }
        }
        
        async function logLocationChange(gameId, fromLocation, toLocation, action = 'MOVE') {
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            const timestamp = new Date().toISOString();
            
            try {
                const travelData = [
                    timestamp,      // A: Timestamp
                    gameId,         // B: Game ID
                    fromLocation,   // C: From Location
                    toLocation,     // D: To Location
                    action          // E: Action (CHECKOUT/CHECKIN/MOVE)
                ];
                
                if (appsScriptUrl) {
                    await fetch(appsScriptUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'append',
                            sheet: 'TravelHistory',
                            row: travelData
                        })
                    });
                    
                    return true;
                }
                
                // Otherwise provide manual instruction
                const csvRow = travelData.map(cell => `"${cell}"`).join(',');
                console.log('Add this to TravelHistory sheet:', csvRow);
                return false;
                
            } catch (error) {
                console.error('Error logging location change:', error);
                return false;
            }
        }
        
        // Updated location change handlers
        async function handleCheckout(data) {
            if (checkoutWorkflow.step === 'game') {
                if (data.type !== 'GAME') {
                    showStatus('Please scan a game QR code', 'error');
                    return;
                }
                
                // Verify game exists
                const gameInfo = await getGameInfo(data.id);
                if (!gameInfo) {
                    showStatus('Game not found in inventory', 'error');
                    return;
                }
                
                checkoutWorkflow.gameId = data.id;
                checkoutWorkflow.gameTitle = gameInfo.title;
                checkoutWorkflow.fromLocation = gameInfo.location;
                checkoutWorkflow.step = 'bin';
                showWorkflowState(`Step 2: Now scan the bin QR code you're taking "${gameInfo.title}" FROM`);
                
            } else if (checkoutWorkflow.step === 'bin') {
                if (data.type !== 'BIN') {
                    showStatus('Please scan a bin QR code', 'error');
                    return;
                }
                
                checkoutWorkflow.binId = data.id;
                
                try {
                    // Update game location
                    await updateGameLocation(checkoutWorkflow.gameId, 'CHECKED_OUT');
                    
                    // Log the location change
                    await logLocationChange(
                        checkoutWorkflow.gameId,
                        checkoutWorkflow.fromLocation,
                        'CHECKED_OUT',
                        'CHECKOUT'
                    );
                    
                    // Show friendly bin identifier
                    let binDisplay = checkoutWorkflow.binId;
                    if (checkoutWorkflow.binId.length > 20 && !checkoutWorkflow.binId.includes(':')) {
                        binDisplay = 'bin ' + checkoutWorkflow.binId.substring(0, 8) + '...';
                    }
                    
                    showStatus(`‚úÖ ${checkoutWorkflow.gameTitle} checked out from ${binDisplay}!`, 'success');
                    
                    // Log this as a play event too
                    await logEnhancedGamePlay(checkoutWorkflow.gameId, '', '', 0, 'Checked out', '');
                    
                    // Reset workflow
                    checkoutWorkflow = { gameId: null, gameTitle: null, binId: null, step: 'game' };
                    hideWorkflowState();
                } catch (error) {
                    showStatus('Error checking out game: ' + error.message, 'error');
                }
            }
        }
        
        async function handleCheckin(data) {
            if (checkoutWorkflow.step === 'game') {
                if (data.type !== 'GAME') {
                    showStatus('Please scan a game QR code', 'error');
                    return;
                }
                
                // Verify game exists
                const gameInfo = await getGameInfo(data.id);
                if (!gameInfo) {
                    showStatus('Game not found in inventory', 'error');
                    return;
                }
                
                checkoutWorkflow.gameId = data.id;
                checkoutWorkflow.gameTitle = gameInfo.title;
                checkoutWorkflow.fromLocation = gameInfo.location;
                checkoutWorkflow.step = 'bin';
                showWorkflowState(`Step 2: Now scan the bin QR code you're putting "${gameInfo.title}" INTO`);
                
            } else if (checkoutWorkflow.step === 'bin') {
                if (data.type !== 'BIN') {
                    showStatus('Please scan a bin QR code', 'error');
                    return;
                }
                
                checkoutWorkflow.binId = data.id;
                
                try {
                    // Update game location
                    await updateGameLocation(checkoutWorkflow.gameId, checkoutWorkflow.binId);
                    
                    // Log the location change
                    await logLocationChange(
                        checkoutWorkflow.gameId,
                        checkoutWorkflow.fromLocation,
                        checkoutWorkflow.binId,
                        'CHECKIN'
                    );
                    
                    // Show friendly bin identifier
                    let binDisplay = checkoutWorkflow.binId;
                    if (checkoutWorkflow.binId.length > 20 && !checkoutWorkflow.binId.includes(':')) {
                        binDisplay = 'bin ' + checkoutWorkflow.binId.substring(0, 8) + '...';
                    }
                    
                    showStatus(`‚úÖ ${checkoutWorkflow.gameTitle} checked into ${binDisplay}!`, 'success');
                    
                    // Reset workflow
                    checkoutWorkflow = { gameId: null, gameTitle: null, binId: null, step: 'game' };
                    hideWorkflowState();
                } catch (error) {
                    showStatus('Error checking in game: ' + error.message, 'error');
                }
            }
        }
        
        // Enhanced play logging
        async function handleLogPlay(data) {
            if (data.type !== 'GAME') {
                showStatus('Please scan a game QR code', 'error');
                // Restart scanner
                setTimeout(() => startScanning(), 2000);
                return;
            }
            
            try {
                showStatus('Loading game information...', 'success');
                const gameInfo = await getGameInfo(data.id);
                
                if (!gameInfo) {
                    showStatus('Game not found in inventory', 'error');
                    // Restart scanner
                    setTimeout(() => startScanning(), 2000);
                    return;
                }
                
                // Store current game and show enhanced log form
                currentPlayGame = gameInfo;
                showPlayLogForm(gameInfo);
                
            } catch (error) {
                if (error.message.includes('rate limit')) {
                    showStatus('Too many requests. Please wait 10 seconds and try again.', 'error');
                } else {
                    showStatus('Error loading game: ' + error.message, 'error');
                }
                // Restart scanner after error
                setTimeout(() => startScanning(), 3000);
            }
        }
        
        async function showPlayLogForm(gameInfo) {
            if (!gameInfo) {
                showStatus('No game information available', 'error');
                return;
            }
            
            // Store current game
            currentPlayGame = gameInfo;
            
            // Hide scan section, show play log form
            document.getElementById('scan-section').classList.add('hidden');
            document.getElementById('play-log-section').classList.remove('hidden');
            
            // Set game info
            document.getElementById('play-game-info').innerHTML = `
                <strong>Game:</strong> ${gameInfo.title}<br>
                <strong>ID:</strong> ${gameInfo.id}
            `;
            
            // Load session templates
            try {
                const templates = await loadSessionTemplates();
                const templateSelect = document.getElementById('play-session-template');
                templateSelect.innerHTML = '<option value="">No template</option>';
                templates.forEach(template => {
                    templateSelect.innerHTML += `<option value="${template.id}">${template.name}</option>`;
                });
            } catch (error) {
                console.log('Could not load session templates:', error);
                const templateSelect = document.getElementById('play-session-template');
                templateSelect.innerHTML = '<option value="">No template</option>';
            }
            
            // Reset form
            document.getElementById('play-players').value = '';
            document.getElementById('play-winner').value = '';
            document.getElementById('play-notes').value = '';
            setRating(0);
        }
        
        function cancelLogPlay() {
            currentPlayGame = null;
            document.getElementById('play-log-section').classList.add('hidden');
            document.getElementById('scan-section').classList.remove('hidden');
            // Restart scanning
            setTimeout(() => startScanning(), 500);
        }
        
        async function confirmLogPlay() {
            if (!currentPlayGame) return;
            
            const players = document.getElementById('play-players').value;
            const winner = document.getElementById('play-winner').value;
            const notes = document.getElementById('play-notes').value;
            const templateId = document.getElementById('play-session-template').value;
            const rating = currentRating;
            
            // If template selected, load players from template
            let finalPlayers = players;
            if (templateId && !players) {
                const template = sessionTemplates.find(t => t.id === templateId);
                if (template) {
                    finalPlayers = template.players;
                }
            }
            
            try {
                await logEnhancedGamePlay(currentPlayGame.id, finalPlayers, winner, rating, notes, templateId);
                showStatus(`Play logged for ${currentPlayGame.title}!`, 'success');
                cancelLogPlay();
            } catch (error) {
                showStatus('Error logging play: ' + error.message, 'error');
            }
        }
        
        async function logEnhancedGamePlay(gameId, players, winner, rating, notes, sessionId = '') {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            try {
                const timestamp = new Date().toLocaleString();
                const playData = [
                    timestamp,      // A: Timestamp
                    gameId,         // B: Game ID
                    players,        // C: Players
                    notes,          // D: Notes
                    winner,         // E: Winner
                    rating || '',   // F: Rating
                    sessionId       // G: Session ID
                ];
                
                // If Apps Script URL is available, use it
                if (appsScriptUrl) {
                    const scriptResponse = await fetch(appsScriptUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'append',
                            sheet: 'PlayLog',
                            row: playData
                        })
                    });
                    
                    return true;
                }
                
                // Otherwise provide manual instruction
                const csvRow = playData.map(cell => `"${cell}"`).join(',');
                showStatus(`Copy this play log entry: ${csvRow}`, 'error');
                console.log('Add this to PlayLog sheet:', csvRow);
                return false;
                
            } catch (error) {
                console.error('Error logging play:', error);
                throw error;
            }
        }
        
        // Players Section
        async function loadPlayerStats() {
            console.log('Loading player stats...');
            
            // Load all data
            await Promise.all([
                loadAllGames(),
                loadAllPlayers(),
                loadEnhancedPlayHistory()
            ]);
            
            console.log(`Loaded ${allGames.length} games, ${allPlayers.length} players, ${playHistory.length} plays`);
            
            // Update all player tabs
            updatePlayerManageTab();
            updatePlayerStatsTab();
            updatePlayerCompareTab();
            updatePlayerHistoryTab();
        }
        
        function setPlayerTab(tab) {
            playerTab = tab;
            document.querySelectorAll('#players-section .tab').forEach(t => t.classList.remove('active'));
            
            // Find and activate the correct tab button
            document.querySelectorAll('#players-section .tab').forEach(t => {
                if ((tab === 'manage' && t.textContent === 'Manage Players') ||
                    (tab === 'stats' && t.textContent === 'Statistics') ||
                    (tab === 'compare' && t.textContent === 'Compare') ||
                    (tab === 'history' && t.textContent === 'Session History')) {
                    t.classList.add('active');
                }
            });
            
            // Hide all player tab content
            document.querySelectorAll('.player-tab-content').forEach(content => {
                content.classList.add('hidden');
            });
            
            // Show selected tab
            switch(tab) {
                case 'manage':
                    document.getElementById('player-manage').classList.remove('hidden');
                    updatePlayerManageTab();
                    break;
                case 'stats':
                    document.getElementById('player-stats').classList.remove('hidden');
                    updatePlayerStatsTab();
                    break;
                case 'compare':
                    document.getElementById('player-compare').classList.remove('hidden');
                    updatePlayerCompareTab();
                    break;
                case 'history':
                    document.getElementById('player-history').classList.remove('hidden');
                    updatePlayerHistoryTab();
                    break;
            }
        }
        
        async function loadAllPlayers() {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            if (!spreadsheetId || !apiKey) {
                console.log('No spreadsheet ID or API key found for loading players');
                return [];
            }
            
            try {
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/Players!A:C?key=${apiKey}`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const rows = data.values || [];
                    
                    allPlayers = [];
                    for (let i = 1; i < rows.length; i++) {
                        const [id, name, email] = rows[i];
                        allPlayers.push({
                            id: id || `PLAYER:${Date.now()}`,
                            name: name || 'Unknown Player',
                            email: email || ''
                        });
                    }
                } else if (response.status === 400) {
                    // Players sheet doesn't exist yet
                    console.log('Players sheet not found, will be created when first player is added');
                    allPlayers = [];
                }
                
                console.log(`Loaded ${allPlayers.length} players from Players sheet`);
                return allPlayers;
            } catch (error) {
                console.error('Error loading players:', error);
                return [];
            }
        }
        
        async function addNewPlayer() {
            const name = document.getElementById('new-player-name').value.trim();
            const email = document.getElementById('new-player-email').value.trim();
            
            if (!name) {
                showStatus('Please enter a player name', 'error');
                return;
            }
            
            // Check if player already exists
            const existingPlayer = allPlayers.find(p => p.name.toLowerCase() === name.toLowerCase());
            if (existingPlayer) {
                showStatus('Player already exists', 'error');
                return;
            }
            
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            const playerId = 'PLAYER:' + Date.now();
            
            try {
                const playerData = [playerId, name, email];
                
                if (appsScriptUrl) {
                    await fetch(appsScriptUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'append',
                            sheet: 'Players',
                            row: playerData
                        })
                    });
                    
                    showStatus(`Added ${name} to players!`, 'success');
                    document.getElementById('new-player-name').value = '';
                    document.getElementById('new-player-email').value = '';
                    
                    await loadAllPlayers();
                    updatePlayerManageTab();
                } else {
                    const csvRow = playerData.map(cell => `"${cell}"`).join(',');
                    showStatus(`Create a "Players" sheet in your Google Sheets with columns: Player ID, Name, Email. Then add: ${csvRow}`, 'error');
                }
                
            } catch (error) {
                showStatus('Error adding player: ' + error.message, 'error');
            }
        }
        
        async function removePlayer(playerId) {
            if (!confirm('Are you sure you want to remove this player? Their play history will be preserved.')) {
                return;
            }
            
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            if (!appsScriptUrl) {
                showStatus('Please enable auto-update to remove players, or delete manually from the Players sheet', 'error');
                return;
            }
            
            // This would require more complex Apps Script implementation
            showStatus(`To remove player, delete their row from the Players sheet (ID: ${playerId})`, 'error');
        }
        
        function updatePlayerManageTab() {
            const container = document.getElementById('all-players-list');
            
            if (!container) {
                console.error('all-players-list container not found!');
                return;
            }
            
            container.innerHTML = '';
            
            console.log('Updating player manage tab with', allPlayers.length, 'players');
            
            if (allPlayers.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No players added yet. Add your first player above!</p>';
                return;
            }
            
            // Get play statistics for each player
            const playerStats = calculateAllPlayerStats();
            
            allPlayers.forEach(player => {
                const stats = playerStats[player.name] || { gamesPlayed: 0, wins: 0 };
                const winRate = stats.gamesPlayed > 0 ? (stats.wins / stats.gamesPlayed * 100).toFixed(1) : 0;
                
                container.innerHTML += `
                    <div class="player-card">
                        <div class="player-card-header">
                            <div>
                                <h4>${player.name}</h4>
                                ${player.email ? `<small style="color: #7f8c8d;">${player.email}</small>` : ''}
                            </div>
                            <div class="player-card-actions">
                                <button class="btn btn-info" onclick="viewPlayerDetails('${player.name}')">View Stats</button>
                                <button class="btn btn-secondary" onclick="removePlayer('${player.id}')">Remove</button>
                            </div>
                        </div>
                        <div class="player-stats-grid">
                            <div class="player-stat-item">
                                <div class="player-stat-value">${stats.gamesPlayed}</div>
                                <div class="player-stat-label">Games Played</div>
                            </div>
                            <div class="player-stat-item">
                                <div class="player-stat-value">${stats.wins}</div>
                                <div class="player-stat-label">Wins</div>
                            </div>
                            <div class="player-stat-item">
                                <div class="player-stat-value">${winRate}%</div>
                                <div class="player-stat-label">Win Rate</div>
                            </div>
                        </div>
                    </div>
                `;
            });
        }
        
        function updatePlayerStatsTab() {
            const container = document.getElementById('player-stats-list');
            container.innerHTML = '';
            
            // Combine registered players and players from play history
            const allPlayerNames = new Set();
            
            // Add registered players
            allPlayers.forEach(player => {
                allPlayerNames.add(player.name);
            });
            
            // Add players from play history
            playHistory.forEach(play => {
                if (play.players) {
                    play.players.split(',').forEach(player => {
                        const trimmedPlayer = player.trim();
                        if (trimmedPlayer) {
                            allPlayerNames.add(trimmedPlayer);
                        }
                    });
                }
            });
            
            if (allPlayerNames.size === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No players found. Add players or log some game plays!</p>';
                return;
            }
            
            Array.from(allPlayerNames).sort().forEach(playerName => {
                const chip = document.createElement('div');
                chip.className = 'player-chip';
                chip.textContent = playerName;
                chip.onclick = () => viewPlayerDetails(playerName);
                container.appendChild(chip);
            });
        }
        
        function updatePlayerCompareTab() {
            const container = document.getElementById('player-compare-list');
            container.innerHTML = '';
            
            // Combine all player names
            const allPlayerNames = new Set();
            
            allPlayers.forEach(player => {
                allPlayerNames.add(player.name);
            });
            
            playHistory.forEach(play => {
                if (play.players) {
                    play.players.split(',').forEach(player => {
                        const trimmedPlayer = player.trim();
                        if (trimmedPlayer) {
                            allPlayerNames.add(trimmedPlayer);
                        }
                    });
                }
            });
            
            if (allPlayerNames.size === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No players found.</p>';
                return;
            }
            
            Array.from(allPlayerNames).sort().forEach(playerName => {
                const chip = document.createElement('div');
                chip.className = 'player-chip';
                chip.textContent = playerName;
                chip.onclick = () => togglePlayerSelection(playerName);
                if (selectedPlayers.has(playerName)) {
                    chip.classList.add('selected');
                }
                container.appendChild(chip);
            });
        }
        
        function updatePlayerHistoryTab() {
            const select = document.getElementById('player-history-select');
            select.innerHTML = '<option value="">Select a player...</option>';
            
            // Combine all player names
            const allPlayerNames = new Set();
            
            allPlayers.forEach(player => {
                allPlayerNames.add(player.name);
            });
            
            playHistory.forEach(play => {
                if (play.players) {
                    play.players.split(',').forEach(player => {
                        const trimmedPlayer = player.trim();
                        if (trimmedPlayer) {
                            allPlayerNames.add(trimmedPlayer);
                        }
                    });
                }
            });
            
            Array.from(allPlayerNames).sort().forEach(playerName => {
                select.innerHTML += `<option value="${playerName}">${playerName}</option>`;
            });
        }
        
        function viewPlayerDetails(playerName) {
            selectedPlayerForStats = playerName;
            setPlayerTab('stats');
            displayDetailedPlayerStats(playerName);
        }
        
        function displayDetailedPlayerStats(playerName) {
            const container = document.getElementById('individual-player-stats');
            container.innerHTML = '';
            
            // Calculate detailed stats for this player
            const stats = calculatePlayerDetailedStats(playerName);
            
            if (stats.gamesPlayed === 0) {
                container.innerHTML = `
                    <div class="player-card">
                        <h3>${playerName}</h3>
                        <p style="text-align: center; color: #7f8c8d; padding: 2rem;">No games played yet.</p>
                    </div>
                `;
                return;
            }
            
            const winRate = (stats.wins / stats.gamesPlayed * 100).toFixed(1);
            const avgRating = stats.ratings.length > 0 
                ? (stats.ratings.reduce((a, b) => a + b, 0) / stats.ratings.length).toFixed(1)
                : 'N/A';
            
            const topGames = Object.entries(stats.favoriteGames)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([game, count]) => `${game} (${count} plays)`);
            
            const topPartners = Object.entries(stats.playPartners)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([partner, count]) => `${partner} (${count} games)`);
            
            const recentGames = stats.recentPlays.slice(0, 10);
            
            container.innerHTML = `
                <div class="player-card">
                    <h3>${playerName}'s Detailed Statistics</h3>
                    
                    <div class="player-stats-grid" style="margin: 2rem 0;">
                        <div class="player-stat-item">
                            <div class="player-stat-value">${stats.gamesPlayed}</div>
                            <div class="player-stat-label">Total Games</div>
                        </div>
                        <div class="player-stat-item">
                            <div class="player-stat-value">${stats.wins}</div>
                            <div class="player-stat-label">Wins</div>
                        </div>
                        <div class="player-stat-item">
                            <div class="player-stat-value">${winRate}%</div>
                            <div class="player-stat-label">Win Rate</div>
                        </div>
                        <div class="player-stat-item">
                            <div class="player-stat-value">${stats.uniqueGames}</div>
                            <div class="player-stat-label">Unique Games</div>
                        </div>
                        <div class="player-stat-item">
                            <div class="player-stat-value">${avgRating}</div>
                            <div class="player-stat-label">Avg Rating Given</div>
                        </div>
                        <div class="player-stat-item">
                            <div class="player-stat-value">${stats.streak}</div>
                            <div class="player-stat-label">Current Streak</div>
                        </div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 2rem;">
                        <div>
                            <h4>Favorite Games</h4>
                            ${topGames.length > 0 ? topGames.map(game => `<div style="padding: 0.5rem 0;">${game}</div>`).join('') : '<p style="color: #7f8c8d;">No games played yet</p>'}
                        </div>
                        
                        <div>
                            <h4>Frequent Play Partners</h4>
                            ${topPartners.length > 0 ? topPartners.map(partner => `<div style="padding: 0.5rem 0;">${partner}</div>`).join('') : '<p style="color: #7f8c8d;">No play partners yet</p>'}
                        </div>
                    </div>
                    
                    <div style="margin-top: 2rem;">
                        <h4>Recent Games</h4>
                        ${recentGames.length > 0 ? recentGames.map(play => `
                            <div class="session-history-item">
                                <div class="session-history-header">
                                    <span>${play.gameTitle}</span>
                                    <span>${new Date(play.timestamp).toLocaleDateString()}</span>
                                </div>
                                <div class="session-history-games">
                                    ${play.won ? 'üèÜ Won' : 'Lost'} ‚Ä¢ 
                                    ${play.rating ? `Rated ${play.rating}/5` : 'No rating'} ‚Ä¢ 
                                    With: ${play.otherPlayers.join(', ') || 'Solo'}
                                </div>
                            </div>
                        `).join('') : '<p style="color: #7f8c8d;">No recent games</p>'}
                    </div>
                </div>
            `;
        }
        
        function calculatePlayerDetailedStats(playerName) {
            const stats = {
                gamesPlayed: 0,
                wins: 0,
                uniqueGames: new Set(),
                favoriteGames: {},
                playPartners: {},
                ratings: [],
                recentPlays: [],
                streak: 0
            };
            
            let currentStreak = 0;
            let lastWon = null;
            
            // Sort plays by date for streak calculation
            const sortedPlays = [...playHistory].sort((a, b) => 
                new Date(b.timestamp) - new Date(a.timestamp)
            );
            
            sortedPlays.forEach(play => {
                const gamePlayers = play.players ? play.players.split(',').map(p => p.trim()) : [];
                
                if (gamePlayers.includes(playerName)) {
                    stats.gamesPlayed++;
                    
                    const won = play.winner && play.winner.trim() === playerName;
                    if (won) {
                        stats.wins++;
                    }
                    
                    // Calculate streak
                    if (lastWon === null) {
                        lastWon = won;
                        currentStreak = won ? 1 : -1;
                    } else if ((won && lastWon) || (!won && !lastWon)) {
                        currentStreak = won ? Math.abs(currentStreak) + 1 : -(Math.abs(currentStreak) + 1);
                    } else {
                        stats.streak = currentStreak;
                        currentStreak = won ? 1 : -1;
                        lastWon = won;
                    }
                    
                    // Track unique games
                    stats.uniqueGames.add(play.gameId);
                    
                    // Track favorite games
                    const game = allGames.find(g => g.id === play.gameId);
                    const gameTitle = game?.title || play.gameId;
                    stats.favoriteGames[gameTitle] = (stats.favoriteGames[gameTitle] || 0) + 1;
                    
                    // Track play partners
                    gamePlayers.forEach(partner => {
                        if (partner !== playerName) {
                            stats.playPartners[partner] = (stats.playPartners[partner] || 0) + 1;
                        }
                    });
                    
                    // Track ratings
                    if (play.rating) {
                        stats.ratings.push(parseInt(play.rating));
                    }
                    
                    // Add to recent plays
                    stats.recentPlays.push({
                        timestamp: play.timestamp,
                        gameId: play.gameId,
                        gameTitle,
                        won,
                        rating: play.rating,
                        otherPlayers: gamePlayers.filter(p => p !== playerName)
                    });
                }
            });
            
            // Set final streak if not set
            if (stats.streak === 0 && currentStreak !== 0) {
                stats.streak = currentStreak;
            }
            
            stats.uniqueGames = stats.uniqueGames.size;
            stats.recentPlays.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            
            return stats;
        }
        
        function calculateAllPlayerStats() {
            const playerStats = {};
            
            playHistory.forEach(play => {
                const gamePlayers = play.players ? play.players.split(',').map(p => p.trim()) : [];
                const winner = play.winner ? play.winner.trim() : '';
                
                gamePlayers.forEach(player => {
                    if (!playerStats[player]) {
                        playerStats[player] = {
                            gamesPlayed: 0,
                            wins: 0
                        };
                    }
                    
                    playerStats[player].gamesPlayed++;
                    if (winner === player) {
                        playerStats[player].wins++;
                    }
                });
            });
            
            return playerStats;
        }
        
        async function loadPlayerSessionHistory() {
            const playerName = document.getElementById('player-history-select').value;
            if (!playerName) {
                document.getElementById('player-session-history').innerHTML = '';
                return;
            }
            
            const container = document.getElementById('player-session-history');
            container.innerHTML = '<h4>Loading session history...</h4>';
            
            // Group plays by session (date)
            const sessionsByDate = {};
            
            playHistory.forEach(play => {
                const gamePlayers = play.players ? play.players.split(',').map(p => p.trim()) : [];
                
                if (gamePlayers.includes(playerName)) {
                    const date = new Date(play.timestamp).toLocaleDateString();
                    
                    if (!sessionsByDate[date]) {
                        sessionsByDate[date] = {
                            date: play.timestamp,
                            games: [],
                            wins: 0,
                            totalGames: 0,
                            partners: new Set()
                        };
                    }
                    
                    const game = allGames.find(g => g.id === play.gameId);
                    const won = play.winner && play.winner.trim() === playerName;
                    
                    sessionsByDate[date].games.push({
                        title: game?.title || play.gameId,
                        won,
                        rating: play.rating,
                        notes: play.notes
                    });
                    
                    sessionsByDate[date].totalGames++;
                    if (won) sessionsByDate[date].wins++;
                    
                    gamePlayers.forEach(p => {
                        if (p !== playerName) sessionsByDate[date].partners.add(p);
                    });
                }
            });
            
            // Convert to array and sort by date
            const sessions = Object.values(sessionsByDate).sort((a, b) => 
                new Date(b.date) - new Date(a.date)
            );
            
            if (sessions.length === 0) {
                container.innerHTML = `<p style="text-align: center; color: #7f8c8d; padding: 2rem;">No session history for ${playerName}</p>`;
                return;
            }
            
            container.innerHTML = `
                <h4>${playerName}'s Session History</h4>
                <p style="margin: 1rem 0;">Total Sessions: ${sessions.length}</p>
                ${sessions.map(session => {
                    const winRate = session.totalGames > 0 ? (session.wins / session.totalGames * 100).toFixed(0) : 0;
                    return `
                        <div class="session-history-item">
                            <div class="session-history-header">
                                <span>${new Date(session.date).toLocaleDateString()}</span>
                                <span>${session.wins}/${session.totalGames} wins (${winRate}%)</span>
                            </div>
                            <div class="session-history-games">
                                <strong>Games:</strong> ${session.games.map(g => 
                                    `${g.title}${g.won ? ' üèÜ' : ''}${g.rating ? ` (${g.rating}‚òÖ)` : ''}`
                                ).join(', ')}<br>
                                <strong>Played with:</strong> ${Array.from(session.partners).join(', ') || 'Solo'}
                            </div>
                        </div>
                    `;
                }).join('')}
            `;
        }
        
        function togglePlayerSelection(player) {
            if (selectedPlayers.has(player)) {
                selectedPlayers.delete(player);
            } else {
                selectedPlayers.add(player);
            }
            
            // Update UI
            updatePlayerCompareTab();
            
            // Update comparison if 2+ players selected
            if (selectedPlayers.size >= 2) {
                updatePlayerComparison();
            } else {
                document.getElementById('player-comparison').classList.add('hidden');
            }
        }
        
        async function updatePlayerComparison() {
            // Ensure games are loaded
            if (allGames.length === 0) {
                await loadAllGames();
            }
            
            const plays = await loadEnhancedPlayHistory();
            const players = Array.from(selectedPlayers);
            
            document.getElementById('player-comparison').classList.remove('hidden');
            
            // Calculate head-to-head stats
            const h2hStats = calculateH2HStats(plays, players);
            displayH2HStats(h2hStats);
            
            // Update comparison chart
            updatePlayerComparisonChart(plays, players);
        }
        
        function calculateH2HStats(plays, players) {
            const stats = {};
            
            players.forEach(p1 => {
                stats[p1] = {};
                players.forEach(p2 => {
                    if (p1 !== p2) {
                        stats[p1][p2] = { games: 0, wins: 0 };
                    }
                });
            });
            
            // Count games and wins
            plays.forEach(play => {
                const gamePlayers = play.players ? play.players.split(',').map(p => p.trim()) : [];
                const winner = play.winner ? play.winner.trim() : '';
                
                // Check if this game includes our selected players
                const includedPlayers = players.filter(p => gamePlayers.includes(p));
                
                if (includedPlayers.length >= 2) {
                    includedPlayers.forEach(p1 => {
                        includedPlayers.forEach(p2 => {
                            if (p1 !== p2) {
                                stats[p1][p2].games++;
                                if (winner === p1) {
                                    stats[p1][p2].wins++;
                                }
                            }
                        });
                    });
                }
            });
            
            return stats;
        }
        
        function displayH2HStats(h2hStats) {
            const container = document.getElementById('h2h-stats');
            container.innerHTML = '';
            
            const players = Object.keys(h2hStats);
            
            // Create comparison table
            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<tr><th style="padding: 0.5rem; border: 1px solid #ddd;">Player</th>';
            
            players.forEach(p => {
                html += `<th style="padding: 0.5rem; border: 1px solid #ddd;">${p}</th>`;
            });
            html += '</tr>';
            
            players.forEach(p1 => {
                html += `<tr><th style="padding: 0.5rem; border: 1px solid #ddd; text-align: left;">${p1}</th>`;
                players.forEach(p2 => {
                    if (p1 === p2) {
                        html += '<td style="padding: 0.5rem; border: 1px solid #ddd; background: #ecf0f1;">-</td>';
                    } else {
                        const stats = h2hStats[p1][p2];
                        const winRate = stats.games > 0 ? (stats.wins / stats.games * 100).toFixed(0) : 0;
                        html += `<td style="padding: 0.5rem; border: 1px solid #ddd; text-align: center;">
                            ${stats.wins}/${stats.games}<br>
                            <small>${winRate}%</small>
                        </td>`;
                    }
                });
                html += '</tr>';
            });
            
            html += '</table>';
            container.innerHTML = html;
        }
        
        function updatePlayerComparisonChart(plays, players) {
            const ctx = document.getElementById('player-comparison-chart').getContext('2d');
            
            // Calculate games played by month
            const monthlyData = {};
            
            plays.forEach(play => {
                const date = new Date(play.timestamp);
                const monthKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}`;
                
                if (!monthlyData[monthKey]) {
                    monthlyData[monthKey] = {};
                    players.forEach(p => monthlyData[monthKey][p] = 0);
                }
                
                const gamePlayers = play.players ? play.players.split(',').map(p => p.trim()) : [];
                players.forEach(p => {
                    if (gamePlayers.includes(p)) {
                        monthlyData[monthKey][p]++;
                    }
                });
            });
            
            const labels = Object.keys(monthlyData).sort();
            const datasets = players.map((player, index) => ({
                label: player,
                data: labels.map(month => monthlyData[month][player] || 0),
                borderColor: `hsl(${index * 360 / players.length}, 70%, 50%)`,
                backgroundColor: `hsla(${index * 360 / players.length}, 70%, 50%, 0.2)`,
                tension: 0.1
            }));
            
            if (playerComparisonChart) {
                playerComparisonChart.destroy();
            }
            
            playerComparisonChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Games Played Over Time'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Games Played'
                            }
                        }
                    }
                }
            });
        }
        
        // Session templates
        async function loadSessionTemplates() {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            try {
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/SessionTemplates!A:D?key=${apiKey}`
                );
                
                if (response.ok) {
                    const data = await response.json();
                    const rows = data.values || [];
                    
                    sessionTemplates = [];
                    for (let i = 1; i < rows.length; i++) {
                        const [id, name, players, notes] = rows[i];
                        sessionTemplates.push({ id, name, players, notes });
                    }
                } else if (response.status === 400) {
                    // Sheet might not exist yet
                    console.log('SessionTemplates sheet not found, will be created when first template is added');
                    sessionTemplates = [];
                } else {
                    console.error('Error loading session templates:', response.status);
                    sessionTemplates = [];
                }
                
                displaySessionTemplates();
                return sessionTemplates;
                
            } catch (error) {
                console.error('Error loading session templates:', error);
                sessionTemplates = [];
                displaySessionTemplates();
                return [];
            }
        }
        
        function displaySessionTemplates() {
            const container = document.getElementById('session-templates-list');
            container.innerHTML = '';
            
            if (sessionTemplates.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No templates created yet. Create your first template above!</p>';
                return;
            }
            
            sessionTemplates.forEach(template => {
                container.innerHTML += `
                    <div class="session-template">
                        <div>
                            <strong>${template.name}</strong><br>
                            <small>Players: ${template.players}</small><br>
                            ${template.notes ? `<small>${template.notes}</small>` : ''}
                        </div>
                        <button class="btn btn-secondary" onclick="deleteSessionTemplate('${template.id}')">Delete</button>
                    </div>
                `;
            });
        }
        
        async function createSessionTemplate() {
            const name = document.getElementById('template-name').value;
            const players = document.getElementById('template-players').value;
            const notes = document.getElementById('template-notes').value;
            
            if (!name || !players) {
                showStatus('Please enter template name and players', 'error');
                return;
            }
            
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            const templateId = 'TEMPLATE:' + Date.now();
            
            try {
                const templateData = [templateId, name, players, notes];
                
                if (appsScriptUrl) {
                    await fetch(appsScriptUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'append',
                            sheet: 'SessionTemplates',
                            row: templateData
                        })
                    });
                    
                    showStatus('Template created successfully!', 'success');
                    document.getElementById('template-name').value = '';
                    document.getElementById('template-players').value = '';
                    document.getElementById('template-notes').value = '';
                    
                    await loadSessionTemplates();
                } else {
                    const csvRow = templateData.map(cell => `"${cell}"`).join(',');
                    showStatus(`Create a "SessionTemplates" sheet in your Google Sheets with columns: Template ID, Template Name, Regular Players, Notes. Then add: ${csvRow}`, 'error');
                }
                
            } catch (error) {
                showStatus('Error creating template: ' + error.message, 'error');
            }
        }
        
        async function deleteSessionTemplate(templateId) {
            // This would require more complex Apps Script implementation
            showStatus('Delete template ' + templateId + ' manually from the SessionTemplates sheet', 'error');
        }
        
        // Enhanced play history loading
        async function loadEnhancedPlayHistory() {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            if (!spreadsheetId || !apiKey) {
                console.log('No spreadsheet ID or API key found');
                return [];
            }
            
            try {
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/PlayLog!A:G?key=${apiKey}`
                );
                
                const data = await response.json();
                const rows = data.values || [];
                
                console.log(`Loaded ${rows.length - 1} play history entries from PlayLog sheet`);
                if (rows.length > 1) {
                    console.log('PlayLog sample row:', rows[1]);
                }
                
                playHistory = [];
                for (let i = 1; i < rows.length; i++) {
                    const [timestamp, gameId, players, notes, winner, rating, sessionId] = rows[i];
                    playHistory.push({
                        timestamp,
                        gameId,
                        players: players || '',
                        notes: notes || '',
                        winner: winner || '',
                        rating: rating || '',
                        sessionId: sessionId || ''
                    });
                }
                
                // Debug: Show a sample of play history
                if (playHistory.length > 0) {
                    console.log('Sample play history entry:', playHistory[0]);
                }
                
                return playHistory;
            } catch (error) {
                console.error('Error loading play history:', error);
                return [];
            }
        }
        
        // Trends chart
        function updateTrendsChart() {
            if (!playHistory || playHistory.length === 0) {
                console.log('No play history data available for trends chart');
                const ctx = document.getElementById('trends-chart').getContext('2d');
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
                ctx.font = '16px Arial';
                ctx.textAlign = 'center';
                ctx.fillText('No play history data available', ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }
            
            const period = document.getElementById('trends-period').value;
            const ctx = document.getElementById('trends-chart').getContext('2d');
            
            // Calculate date range
            const endDate = new Date();
            let startDate = new Date();
            let groupBy = 'day';
            
            switch(period) {
                case 'week':
                    startDate.setDate(endDate.getDate() - 7);
                    groupBy = 'day';
                    break;
                case 'month':
                    startDate.setMonth(endDate.getMonth() - 1);
                    groupBy = 'day';
                    break;
                case 'quarter':
                    startDate.setMonth(endDate.getMonth() - 3);
                    groupBy = 'week';
                    break;
                case 'year':
                    startDate.setFullYear(endDate.getFullYear() - 1);
                    groupBy = 'month';
                    break;
            }
            
            // Group plays by period
            const playData = {};
            playHistory.forEach(play => {
                const playDate = new Date(play.timestamp);
                if (playDate >= startDate && playDate <= endDate) {
                    let key;
                    
                    if (groupBy === 'day') {
                        key = playDate.toISOString().split('T')[0];
                    } else if (groupBy === 'week') {
                        const weekStart = new Date(playDate);
                        weekStart.setDate(playDate.getDate() - playDate.getDay());
                        key = weekStart.toISOString().split('T')[0];
                    } else {
                        key = `${playDate.getFullYear()}-${String(playDate.getMonth() + 1).padStart(2, '0')}`;
                    }
                    
                    playData[key] = (playData[key] || 0) + 1;
                }
            });
            
            const labels = Object.keys(playData).sort();
            const data = labels.map(label => playData[label]);
            
            if (trendsChart) {
                trendsChart.destroy();
            }
            
            trendsChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels,
                    datasets: [{
                        label: 'Games Played',
                        data,
                        borderColor: '#3498db',
                        backgroundColor: 'rgba(52, 152, 219, 0.2)',
                        tension: 0.1
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Play Frequency Over Time'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Number of Plays'
                            }
                        }
                    }
                }
            });
        }
        
        // Ratings display
        async function updateRatingsDisplay() {
            const plays = await loadEnhancedPlayHistory();
            
            // Ensure games are loaded
            if (allGames.length === 0) {
                await loadAllGames();
            }
            
            // Calculate average ratings per game
            const gameRatings = {};
            
            plays.forEach(play => {
                if (play.rating) {
                    if (!gameRatings[play.gameId]) {
                        gameRatings[play.gameId] = [];
                    }
                    gameRatings[play.gameId].push(parseInt(play.rating));
                }
            });
            
            // Calculate averages and sort
            const averageRatings = Object.entries(gameRatings).map(([gameId, ratings]) => {
                const avg = ratings.reduce((a, b) => a + b, 0) / ratings.length;
                const game = allGames.find(g => g.id === gameId);
                return {
                    gameId,
                    title: game?.title || gameId,
                    avgRating: avg,
                    ratingCount: ratings.length
                };
            }).sort((a, b) => b.avgRating - a.avgRating);
            
            // Display top rated games
            const container = document.getElementById('top-rated-list');
            container.innerHTML = '';
            
            if (averageRatings.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No ratings recorded yet</p>';
            } else {
                averageRatings.slice(0, 10).forEach(game => {
                    container.innerHTML += `
                        <div class="result-item">
                            <div class="result-item-content">
                                <div class="game-title">${game.title}</div>
                                <div class="game-location">
                                    ${getStarDisplay(game.avgRating)} 
                                    (${game.avgRating.toFixed(1)}/5 from ${game.ratingCount} ratings)
                                </div>
                            </div>
                        </div>
                    `;
                });
            }
            
            // Create rating distribution chart
            updateRatingDistributionChart();
        }
        
        function getStarDisplay(rating) {
            let stars = '';
            for (let i = 1; i <= 5; i++) {
                stars += i <= Math.round(rating) ? '‚òÖ' : '‚òÜ';
            }
            return stars;
        }
        
        function updateRatingDistributionChart() {
            const ctx = document.getElementById('ratings-distribution').getContext('2d');
            
            // Count ratings
            const ratingCounts = { 1: 0, 2: 0, 3: 0, 4: 0, 5: 0 };
            
            playHistory.forEach(play => {
                if (play.rating) {
                    ratingCounts[play.rating]++;
                }
            });
            
            if (ratingsChart) {
                ratingsChart.destroy();
            }
            
            ratingsChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: ['1 Star', '2 Stars', '3 Stars', '4 Stars', '5 Stars'],
                    datasets: [{
                        label: 'Number of Ratings',
                        data: Object.values(ratingCounts),
                        backgroundColor: [
                            '#e74c3c',
                            '#e67e22',
                            '#f1c40f',
                            '#2ecc71',
                            '#27ae60'
                        ]
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Rating Distribution'
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            title: {
                                display: true,
                                text: 'Count'
                            }
                        }
                    }
                }
            });
        }
        
        // Session analysis
        async function updateSessionAnalysis() {
            const plays = await loadEnhancedPlayHistory();
            
            if (plays.length === 0) {
                const container = document.getElementById('session-stats');
                container.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No play sessions recorded yet</p>';
                return;
            }
            
            // Group plays by day
            const sessionsByDay = {};
            
            plays.forEach(play => {
                const date = new Date(play.timestamp).toISOString().split('T')[0];
                if (!sessionsByDay[date]) {
                    sessionsByDay[date] = [];
                }
                sessionsByDay[date].push(play);
            });
            
            // Calculate session statistics
            const sessionStats = Object.entries(sessionsByDay).map(([date, plays]) => {
                const uniqueGames = new Set(plays.map(p => p.gameId)).size;
                const uniquePlayers = new Set();
                plays.forEach(play => {
                    if (play.players) {
                        play.players.split(',').forEach(p => uniquePlayers.add(p.trim()));
                    }
                });
                
                return {
                    date,
                    gameCount: plays.length,
                    uniqueGames,
                    uniquePlayers: uniquePlayers.size,
                    duration: plays.length // Approximate based on game count
                };
            }).sort((a, b) => new Date(b.date) - new Date(a.date));
            
            // Display session stats
            const container = document.getElementById('session-stats');
            container.innerHTML = `
                <p><strong>Total Game Sessions:</strong> ${sessionStats.length}</p>
                <p><strong>Average Games per Session:</strong> ${(sessionStats.reduce((sum, s) => sum + s.gameCount, 0) / sessionStats.length).toFixed(1)}</p>
                <p><strong>Most Popular Day:</strong> ${getMostPopularDay(sessionStats)}</p>
            `;
            
            // Recent sessions
            container.innerHTML += '<h4 style="margin-top: 2rem;">Recent Sessions</h4>';
            sessionStats.slice(0, 5).forEach(session => {
                container.innerHTML += `
                    <div class="result-item">
                        <div class="result-item-content">
                            <div class="game-title">${new Date(session.date).toLocaleDateString()}</div>
                            <div class="game-location">
                                ${session.gameCount} games ‚Ä¢ ${session.uniquePlayers} players ‚Ä¢ ${session.uniqueGames} unique games
                            </div>
                        </div>
                    </div>
                `;
            });
            
            // Update session chart
            updateSessionChart(sessionStats);
        }
        
        function getMostPopularDay(sessionStats) {
            const dayCounts = {};
            sessionStats.forEach(session => {
                const day = new Date(session.date).toLocaleDateString('en-US', { weekday: 'long' });
                dayCounts[day] = (dayCounts[day] || 0) + 1;
            });
            
            return Object.entries(dayCounts)
                .sort((a, b) => b[1] - a[1])[0]?.[0] || 'N/A';
        }
        
        function updateSessionChart(sessionStats) {
            const ctx = document.getElementById('session-chart').getContext('2d');
            
            // Group by month
            const monthlyData = {};
            sessionStats.forEach(session => {
                const month = session.date.substring(0, 7);
                if (!monthlyData[month]) {
                    monthlyData[month] = { sessions: 0, games: 0 };
                }
                monthlyData[month].sessions++;
                monthlyData[month].games += session.gameCount;
            });
            
            const labels = Object.keys(monthlyData).sort();
            
            if (sessionChart) {
                sessionChart.destroy();
            }
            
            sessionChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels,
                    datasets: [{
                        label: 'Sessions',
                        data: labels.map(month => monthlyData[month].sessions),
                        backgroundColor: '#3498db',
                        yAxisID: 'y'
                    }, {
                        label: 'Total Games',
                        data: labels.map(month => monthlyData[month].games),
                        backgroundColor: '#27ae60',
                        yAxisID: 'y1'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: {
                            display: true,
                            text: 'Gaming Sessions by Month'
                        }
                    },
                    scales: {
                        y: {
                            type: 'linear',
                            display: true,
                            position: 'left',
                            title: {
                                display: true,
                                text: 'Sessions'
                            }
                        },
                        y1: {
                            type: 'linear',
                            display: true,
                            position: 'right',
                            title: {
                                display: true,
                                text: 'Games Played'
                            },
                            grid: {
                                drawOnChartArea: false
                            }
                        }
                    }
                }
            });
        }
        
        // Export enhanced player statistics
        function exportPlayerStats() {
            const playerStats = {};
            
            // Calculate comprehensive player statistics
            playHistory.forEach(play => {
                const gamePlayers = play.players ? play.players.split(',').map(p => p.trim()) : [];
                const winner = play.winner ? play.winner.trim() : '';
                const game = allGames.find(g => g.id === play.gameId);
                
                gamePlayers.forEach(player => {
                    if (!playerStats[player]) {
                        playerStats[player] = {
                            gamesPlayed: 0,
                            wins: 0,
                            uniqueGames: new Set(),
                            playDates: [],
                            ratings: [],
                            partners: {}
                        };
                    }
                    
                    playerStats[player].gamesPlayed++;
                    if (winner === player) {
                        playerStats[player].wins++;
                    }
                    playerStats[player].uniqueGames.add(play.gameId);
                    playerStats[player].playDates.push(play.timestamp);
                    
                    if (play.rating) {
                        playerStats[player].ratings.push(parseInt(play.rating));
                    }
                    
                    // Track play partners
                    gamePlayers.forEach(partner => {
                        if (partner !== player) {
                            playerStats[player].partners[partner] = (playerStats[player].partners[partner] || 0) + 1;
                        }
                    });
                });
            });
            
            // Create CSV
            let csv = 'Player,Games Played,Wins,Win Rate,Unique Games,First Play,Last Play,Avg Rating Given,Most Frequent Partner\n';
            
            Object.entries(playerStats).forEach(([player, stats]) => {
                const winRate = stats.gamesPlayed > 0 ? (stats.wins / stats.gamesPlayed * 100).toFixed(1) : 0;
                const avgRating = stats.ratings.length > 0 
                    ? (stats.ratings.reduce((a, b) => a + b, 0) / stats.ratings.length).toFixed(1)
                    : 'N/A';
                const firstPlay = stats.playDates.length > 0 ? new Date(Math.min(...stats.playDates.map(d => new Date(d)))).toLocaleDateString() : '';
                const lastPlay = stats.playDates.length > 0 ? new Date(Math.max(...stats.playDates.map(d => new Date(d)))).toLocaleDateString() : '';
                const topPartner = Object.entries(stats.partners).sort((a, b) => b[1] - a[1])[0];
                
                csv += `"${player}",${stats.gamesPlayed},${stats.wins},${winRate}%,${stats.uniqueGames.size},"${firstPlay}","${lastPlay}",${avgRating},"${topPartner ? topPartner[0] : 'N/A'}"\n`;
            });
            
            downloadCSV(csv, 'player_statistics.csv');
        }
        
        // Search functionality
       function setSearchTab(tab) {
            searchTab = tab;
            // Remove active class from all search tabs
            document.querySelectorAll('#search-section .tab').forEach(t => t.classList.remove('active'));
            
            // Find and activate the clicked tab
            document.querySelectorAll('#search-section .tab').forEach(t => {
                if ((tab === 'all' && t.textContent === 'All Games') ||
                    (tab === 'available' && t.textContent === 'Available') ||
                    (tab === 'checked-out' && t.textContent === 'Checked Out')) {
                    t.classList.add('active');
                }
            });
            
            performSearch();
            }
        
       async function performSearch() {
            const query = document.getElementById('search-input').value.toLowerCase();
            const games = await loadAllGames();
            
            console.log('performSearch - games loaded:', games.length);
            console.log('performSearch - search tab:', searchTab);
            
            let filtered = games;
            
            // Filter by tab
            if (searchTab === 'available') {
                filtered = games.filter(g => g.location !== 'CHECKED_OUT');
            } else if (searchTab === 'checked-out') {
                filtered = games.filter(g => g.location === 'CHECKED_OUT');
            }
            
            // Filter by search query
            if (query) {
                filtered = filtered.filter(g => 
                    g.title.toLowerCase().includes(query) ||
                    g.id.toLowerCase().includes(query) ||
                    (g.bggId && g.bggId.toLowerCase().includes(query))
                );
            }
            
            console.log('performSearch - filtered games:', filtered.length);
            
            displaySearchResults(filtered);
        }
        
        function displaySearchResults(games) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('results-content');
            
            // Clear previous results
            contentDiv.innerHTML = '';
            
            if (!games || games.length === 0) {
                contentDiv.innerHTML = '<h4>No games found</h4><p style="text-align: center; color: #7f8c8d;">Try adjusting your search or filters.</p>';
            } else {
                contentDiv.innerHTML = `<h4>Found ${games.length} games</h4>`;
                
                games.forEach(game => {
                    const locationText = game.location === 'CHECKED_OUT' ? 'Checked Out' : 
                                        game.location === 'NEW' ? 'Not in bin' : 
                                        `Bin: ${game.location}`;
                    
                    const gameDiv = document.createElement('div');
                    gameDiv.className = 'result-item';
                    gameDiv.innerHTML = `
                        ${game.photoUrl ? `<img src="${game.photoUrl}" class="game-thumbnail" alt="${game.title}" onerror="this.style.display='none'">` : ''}
                        <div class="result-item-content">
                            <div class="game-title">${game.title}</div>
                            <div class="game-location">ID: ${game.id} ‚Ä¢ ${locationText}</div>
                        </div>
                        <button class="btn btn-info" onclick="viewGameHistoryById('${game.id}')" style="margin-left: auto;">View History</button>
                    `;
                    contentDiv.appendChild(gameDiv);
                });
            }

            // ADD THIS LINE
            console.log('displaySearchResults: resultsDiv hidden status BEFORE unhiding:', resultsDiv.classList.contains('hidden'));

            // Make sure results div is visible
            resultsDiv.classList.remove('hidden');

            // ADD THIS LINE
            console.log('displaySearchResults: resultsDiv hidden status AFTER unhiding:', resultsDiv.classList.contains('hidden'));
        }
        
        // View game history from search results
        async function viewGameHistoryById(gameId) {
            try {
                const [gameInfo, plays, travels] = await Promise.all([
                    getGameInfo(gameId),
                    loadEnhancedPlayHistory(),
                    loadTravelHistory()
                ]);
                
                if (!gameInfo) {
                    showStatus('Game not found', 'error');
                    return;
                }
                
                currentHistoryGameId = gameId;
                currentHistoryGameInfo = gameInfo;
                displayGameHistory(gameInfo, plays, travels);
                
            } catch (error) {
                showStatus('Error loading game history: ' + error.message, 'error');
            }
        }
        
        // Statistics functionality
        async function loadStatistics() {
            console.log('Loading statistics...');
            
            const games = await loadAllGames();
            const plays = await loadEnhancedPlayHistory();
            
            console.log(`Stats: ${games.length} games, ${plays.length} plays`);
            
            // Calculate stats
            const totalGames = games.length;
            const totalPlays = plays.length;
            const checkedOut = games.filter(g => g.location === 'CHECKED_OUT').length;
            
            // Count plays per game
            const playCounts = {};
            plays.forEach(play => {
                playCounts[play.gameId] = (playCounts[play.gameId] || 0) + 1;
            });
            
            const uniquePlayed = Object.keys(playCounts).length;
            
            // Calculate average players
            let totalPlayers = 0;
            let gamesWithPlayers = 0;
            plays.forEach(play => {
                if (play.players) {
                    const playerCount = play.players.split(',').length;
                    totalPlayers += playerCount;
                    gamesWithPlayers++;
                }
            });
            const avgPlayers = gamesWithPlayers > 0 ? (totalPlayers / gamesWithPlayers).toFixed(1) : 0;
            
            // Update stats display
            document.getElementById('total-games').textContent = totalGames;
            document.getElementById('total-plays').textContent = totalPlays;
            document.getElementById('unique-played').textContent = uniquePlayed;
            document.getElementById('avg-players').textContent = avgPlayers;
            
            // Most played games
            const mostPlayed = Object.entries(playCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            const mostPlayedDiv = document.getElementById('most-played-list');
            mostPlayedDiv.innerHTML = '';
            
            if (mostPlayed.length === 0) {
                mostPlayedDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">No games have been played yet</p>';
            } else {
                for (const [gameId, count] of mostPlayed) {
                    const game = games.find(g => g.id === gameId);
                    if (game) {
                        mostPlayedDiv.innerHTML += `
                            <div class="result-item">
                                <div class="result-item-content">
                                    <div class="game-title">${game.title}</div>
                                    <div class="game-location">${count} plays</div>
                                </div>
                                <button class="btn btn-info" onclick="viewGameHistoryById('${game.id}')" style="margin-left: auto;">View History</button>
                            </div>
                        `;
                    }
                }
            }
            
            // Never played games
            const neverPlayed = games.filter(g => !playCounts[g.id]);
            const neverPlayedDiv = document.getElementById('never-played-list');
            neverPlayedDiv.innerHTML = '';
            
            if (neverPlayed.length === 0) {
                neverPlayedDiv.innerHTML = '<p style="text-align: center; color: #7f8c8d;">All games have been played!</p>';
            } else {
                neverPlayed.slice(0, 10).forEach(game => {
                    neverPlayedDiv.innerHTML += `
                        <div class="result-item">
                            <div class="result-item-content">
                                <div class="game-title">${game.title}</div>
                                <div class="game-location">ID: ${game.id}</div>
                            </div>
                        </div>
                    `;
                });
                
                if (neverPlayed.length > 10) {
                    neverPlayedDiv.innerHTML += `<p style="text-align: center; color: #7f8c8d; margin-top: 1rem;">...and ${neverPlayed.length - 10} more</p>`;
                }
            }
        }
        
        // Bulk operations
        async function loadBulkOperations() {
            const games = await loadAllGames();
            const bins = await loadAllBins();
            
            // Populate bin selector
            const binSelect = document.getElementById('bulk-bin-select');
            binSelect.innerHTML = '<option value="">Select destination bin...</option>';
            bins.forEach(bin => {
                binSelect.innerHTML += `<option value="${bin.id}">${bin.description || bin.id}</option>`;
            });
            
            // Display games with checkboxes
            displayBulkGames(games);
        }
        
        function displayBulkGames(games) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('results-content');
            
            contentDiv.innerHTML = '<h4>Select games for bulk operations</h4>';
            
            games.forEach(game => {
                const checked = selectedGames.has(game.id) ? 'checked' : '';
                contentDiv.innerHTML += `
                    <div class="result-item">
                        <input type="checkbox" id="bulk-${game.id}" ${checked} onchange="toggleGameSelection('${game.id}')">
                        <div class="result-item-content">
                            <div class="game-title">${game.title}</div>
                            <div class="game-location">Current: ${game.location}</div>
                        </div>
                    </div>
                `;
            });
            
            resultsDiv.classList.remove('hidden');
            updateBulkActions();
        }
        
        function toggleGameSelection(gameId) {
            if (selectedGames.has(gameId)) {
                selectedGames.delete(gameId);
            } else {
                selectedGames.add(gameId);
            }
            updateBulkActions();
        }
        
        function updateBulkActions() {
            const count = selectedGames.size;
            document.getElementById('selected-count').textContent = `${count} games selected`;
            
            if (count > 0) {
                document.getElementById('bulk-actions').classList.remove('hidden');
            } else {
                document.getElementById('bulk-actions').classList.add('hidden');
            }
        }
        
        function selectAllGames() {
            allGames.forEach(game => selectedGames.add(game.id));
            displayBulkGames(allGames);
        }
        
        function deselectAllGames() {
            selectedGames.clear();
            displayBulkGames(allGames);
        }
        
        async function bulkMove() {
            const binId = document.getElementById('bulk-bin-select').value;
            if (!binId) {
                showStatus('Please select a destination bin', 'error');
                return;
            }
            
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            showStatus(`Moving ${selectedGames.size} games...`, 'success');
            
            let moved = 0;
            let failed = 0;
            
            for (const gameId of selectedGames) {
                try {
                    // Get current location
                    const gameInfo = await getGameInfo(gameId);
                    const fromLocation = gameInfo ? gameInfo.location : 'Unknown';
                    
                    const result = await updateGameLocation(gameId, binId);
                    if (result) {
                        // Log location change
                        await logLocationChange(gameId, fromLocation, binId, 'MOVE');
                        moved++;
                    } else {
                        failed++;
                    }
                } catch (error) {
                    failed++;
                }
            }
            
            if (failed > 0 && !appsScriptUrl) {
                showStatus(`Moved ${moved} games. ${failed} require manual update due to API limits.`, 'error');
            } else {
                showStatus(`Successfully moved ${selectedGames.size} games!`, 'success');
            }
            
            selectedGames.clear();
            loadBulkOperations();
        }
        
        async function bulkCheckout() {
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            showStatus(`Checking out ${selectedGames.size} games...`, 'success');
            
            let checkedOut = 0;
            let failed = 0;
            
            for (const gameId of selectedGames) {
                try {
                    // Get current location
                    const gameInfo = await getGameInfo(gameId);
                    const fromLocation = gameInfo ? gameInfo.location : 'Unknown';
                    
                    const locationResult = await updateGameLocation(gameId, 'CHECKED_OUT');
                    const playResult = await logEnhancedGamePlay(gameId, '', '', 0, 'Bulk checkout', '');
                    
                    if (locationResult) {
                        // Log location change
                        await logLocationChange(gameId, fromLocation, 'CHECKED_OUT', 'CHECKOUT');
                    }
                    
                    if (locationResult && playResult) {
                        checkedOut++;
                    } else {
                        failed++;
                    }
                } catch (error) {
                    failed++;
                }
            }
            
            if (failed > 0 && !appsScriptUrl) {
                showStatus(`Checked out ${checkedOut} games. ${failed} require manual update due to API limits.`, 'error');
            } else {
                showStatus(`Successfully checked out ${selectedGames.size} games!`, 'success');
            }
            
            selectedGames.clear();
            loadBulkOperations();
        }
        
        // BGG Integration
        async function searchBGG() {
            const query = document.getElementById('bgg-search').value;
            if (!query) {
                showStatus('Please enter a game name to search', 'error');
                return;
            }
            
            showStatus('Searching BoardGameGeek...', 'success');
            
            try {
                const response = await fetch(`${CORS_PROXY}${BGG_API_BASE}/search?query=${encodeURIComponent(query)}&type=boardgame`);
                const text = await response.text();
                
                // Parse XML response
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                const items = xml.querySelectorAll('item');
                
                const results = Array.from(items).slice(0, 10).map(item => ({
                    id: item.getAttribute('id'),
                    name: item.querySelector('name[type="primary"]')?.getAttribute('value') || '',
                    year: item.querySelector('yearpublished')?.getAttribute('value') || ''
                }));
                
                displayBGGResults(results);
            } catch (error) {
                showStatus('Error searching BGG: ' + error.message, 'error');
            }
        }
        
        function displayBGGResults(results) {
            const resultsDiv = document.getElementById('bgg-results');
            resultsDiv.innerHTML = '<h4>BoardGameGeek Search Results</h4>';
            
            results.forEach(game => {
                resultsDiv.innerHTML += `
                    <div class="result-item">
                        <div class="result-item-content">
                            <div class="game-title">${game.name} ${game.year ? `(${game.year})` : ''}</div>
                            <div class="game-location">BGG ID: ${game.id}</div>
                        </div>
                        <button class="btn btn-primary" onclick="importBGGGame('${game.id}', '${game.name.replace(/'/g, "\\'").replace(/"/g, "&quot;")}')">Import</button>
                    </div>
                `;
            });
            
            resultsDiv.classList.remove('hidden');
        }
        
        async function importBGGGame(bggId, name) {
            const gameId = `GAME:BGG${bggId}`;
            showStatus(`Importing ${name}...`, 'success');
            
            try {
                // Fetch detailed game info from BGG
                const response = await fetch(`${CORS_PROXY}${BGG_API_BASE}/thing?id=${bggId}`);
                const text = await response.text();
                
                // Parse XML response
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                const item = xml.querySelector('item');
                
                const thumbnail = item.querySelector('thumbnail')?.textContent || '';
                
                // Check if game already exists
                const existingGames = await loadAllGames();
                const exists = existingGames.some(g => g.bggId === bggId || g.id === gameId);
                
                if (exists) {
                    showStatus('Game already exists in your collection', 'error');
                    return;
                }
                
                // Ask for bin location
                const bins = await loadAllBins();
                let binOptions = '<option value="NEW">Add to inventory (no bin)</option>';
                bins.forEach(bin => {
                    binOptions += `<option value="${bin.id}">${bin.description || bin.id}</option>`;
                });
                
                const resultsDiv = document.getElementById('bgg-results');
                resultsDiv.innerHTML = `
                    <h4>Import Game Details</h4>
                    <div class="result-item">
                        ${thumbnail ? `<img src="${thumbnail}" class="game-thumbnail" alt="${name}">` : ''}
                        <div class="result-item-content">
                            <div class="game-title">${name}</div>
                            <div class="game-location">BGG ID: ${bggId}</div>
                        </div>
                    </div>
                    <p style="margin-top: 1rem;">Select location:</p>
                    <select id="import-game-bin" style="width: 100%; padding: 0.5rem; margin: 0.5rem 0;">
                        ${binOptions}
                    </select>
                    <button class="btn btn-primary" onclick="confirmSingleGameImport('${gameId}', '${name.replace(/'/g, "\\'").replace(/"/g, "&quot;")}', '${bggId}', '${thumbnail}')" style="width: 100%;">Add to Collection</button>
                `;
                
            } catch (error) {
                showStatus('Error fetching game details: ' + error.message, 'error');
            }
        }
        
        async function confirmSingleGameImport(gameId, name, bggId, thumbnail) {
            const binId = document.getElementById('import-game-bin').value;
            const location = binId === 'NEW' ? 'NEW' : binId;
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            try {
                // Create game data
                const gameData = [
                    gameId,      // Game ID
                    name,        // Title
                    location,    // Current Location
                    bggId,       // BGG ID
                    thumbnail    // Photo URL
                ];
                
                // If Apps Script is available, use it
                if (appsScriptUrl) {
                    showStatus('Adding game to collection...', 'success');
                    
                    await fetch(appsScriptUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'append',
                            sheet: 'Games',
                            row: gameData
                        })
                    });
                    
                    showStatus(`Successfully added ${name} to your collection!`, 'success');
                    document.getElementById('bgg-results').innerHTML = '';
                    document.getElementById('bgg-search').value = '';
                    return;
                }
                
                // Otherwise, show copy instructions
                const csvRow = gameData.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',');
                
                // Display copy instructions
                const resultsDiv = document.getElementById('bgg-results');
                resultsDiv.innerHTML = `
                    <h4>Add Game to Collection</h4>
                    <div class="result-item">
                        ${thumbnail ? `<img src="${thumbnail}" class="game-thumbnail" alt="${name}">` : ''}
                        <div class="result-item-content">
                            <div class="game-title">${name}</div>
                            <div class="game-location">Location: ${location}</div>
                        </div>
                    </div>
                    <p style="margin-top: 1rem;">Copy this row and paste it into your Games sheet:</p>
                    <textarea style="width: 100%; height: 60px; margin: 0.5rem 0; font-family: monospace; font-size: 0.8rem;" readonly>${csvRow}</textarea>
                    <button class="btn btn-primary" onclick="copySingleGameData()" style="width: 100%;">Copy to Clipboard</button>
                `;
                
                // Store for copy function
                window.singleGameCSV = csvRow;
                
            } catch (error) {
                showStatus('Error preparing game data: ' + error.message, 'error');
            }
        }
        
        function copySingleGameData() {
            const textarea = document.querySelector('#bgg-results textarea');
            textarea.select();
            document.execCommand('copy');
            showStatus('Game data copied! Paste it into the first empty row of your Games sheet.', 'success');
        }
        
        async function importBGGCollection() {
            const username = document.getElementById('bgg-username').value;
            if (!username) {
                showStatus('Please enter a BGG username', 'error');
                return;
            }
            
            showStatus(`Loading collection for ${username}...`, 'success');
            
            try {
                // BGG API requires a retry mechanism as it returns 202 while processing
                let response;
                let attempts = 0;
                const maxAttempts = 10;
                
                do {
                    response = await fetch(`${CORS_PROXY}${BGG_API_BASE}/collection?username=${username}&own=1`);
                    if (response.status === 202) {
                        // BGG is still processing, wait and retry
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        attempts++;
                    }
                } while (response.status === 202 && attempts < maxAttempts);
                
                if (response.status === 202) {
                    showStatus('BGG is taking too long to process. Please try again.', 'error');
                    return;
                }
                
                const text = await response.text();
                
                // Parse XML response
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                const items = xml.querySelectorAll('item');
                
                if (items.length === 0) {
                    showStatus('No games found in collection', 'error');
                    return;
                }
                
                showStatus(`Found ${items.length} games. Importing...`, 'success');
                
                // Display import options
                const resultsDiv = document.getElementById('bgg-results');
                resultsDiv.innerHTML = `
                    <h4>Import ${items.length} Games from BGG</h4>
                    <p>Select a bin for imported games:</p>
                    <select id="import-bin-select" style="width: 100%; padding: 0.5rem; margin: 0.5rem 0;">
                        <option value="IMPORTED">Create new "IMPORTED" location</option>
                    </select>
                    <button class="btn btn-primary" onclick="confirmBGGImport('${username.replace(/'/g, "\\'").replace(/"/g, "&quot;")}')" style="width: 100%;">Confirm Import</button>
                `;
                
                // Load existing bins
                const bins = await loadAllBins();
                const binSelect = document.getElementById('import-bin-select');
                bins.forEach(bin => {
                    binSelect.innerHTML += `<option value="${bin.id}">${bin.description || bin.id}</option>`;
                });
                
                resultsDiv.classList.remove('hidden');
                
            } catch (error) {
                showStatus('Error loading collection: ' + error.message, 'error');
            }
        }
        
        async function confirmBGGImport(username) {
            const binId = document.getElementById('import-bin-select').value;
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            showStatus('Preparing import data...', 'success');
            
            try {
                // Fetch collection again
                let response;
                let attempts = 0;
                const maxAttempts = 10;
                
                do {
                    response = await fetch(`${CORS_PROXY}${BGG_API_BASE}/collection?username=${username}&own=1`);
                    if (response.status === 202) {
                        await new Promise(resolve => setTimeout(resolve, 2000));
                        attempts++;
                    }
                } while (response.status === 202 && attempts < maxAttempts);
                
                const text = await response.text();
                const parser = new DOMParser();
                const xml = parser.parseFromString(text, 'text/xml');
                const items = xml.querySelectorAll('item');
                
                // Get existing games to check for duplicates
                const existingGames = await loadAllGames();
                const existingBGGIds = new Set(existingGames.map(g => g.bggId).filter(id => id));
                
                let imported = 0;
                let skipped = 0;
                const importData = [];
                
                // Process each game
                for (const item of items) {
                    const bggId = item.getAttribute('objectid');
                    const name = item.querySelector('name').textContent;
                    const thumbnail = item.querySelector('thumbnail')?.textContent || '';
                    
                    // Check if already exists
                    if (existingBGGIds.has(bggId)) {
                        skipped++;
                        continue;
                    }
                    
                    // Create row data for spreadsheet
                    importData.push([
                        `GAME:BGG${bggId}`,  // Game ID
                        name,                 // Title
                        binId,               // Current Location
                        bggId,               // BGG ID
                        thumbnail            // Photo URL
                    ]);
                    imported++;
                }
                
                if (importData.length === 0) {
                    showStatus('No new games to import (all games already in collection)', 'error');
                    return;
                }
                
                // If Apps Script is available, use it for automatic import
                if (appsScriptUrl) {
                    showStatus(`Importing ${importData.length} games automatically...`, 'success');
                    
                    // Import in batches to avoid timeout
                    const batchSize = 10;
                    for (let i = 0; i < importData.length; i += batchSize) {
                        const batch = importData.slice(i, i + batchSize);
                        
                        for (const gameData of batch) {
                            await fetch(appsScriptUrl, {
                                method: 'POST',
                                mode: 'no-cors',
                                headers: {
                                    'Content-Type': 'application/json',
                                },
                                body: JSON.stringify({
                                    action: 'append',
                                    sheet: 'Games',
                                    row: gameData
                                })
                            });
                        }
                        
                        const progress = Math.min(i + batchSize, importData.length);
                        showStatus(`Imported ${progress} of ${importData.length} games...`, 'success');
                    }
                    
                    showStatus(`Import complete! Added ${imported} games. ${skipped} duplicates skipped.`, 'success');
                    document.getElementById('bgg-results').classList.add('hidden');
                    return;
                }
                
                // Otherwise, generate CSV for manual import
                let csvContent = importData.map(row => 
                    row.map(cell => `"${cell.replace(/"/g, '""')}"`).join(',')
                ).join('\n');
                
                // Display import instructions
                const resultsDiv = document.getElementById('bgg-results');
                resultsDiv.innerHTML = `
                    <h4>Import Instructions</h4>
                    <p>Due to Google Sheets API limitations, you'll need to paste this data manually:</p>
                    <ol style="text-align: left; margin: 1rem 0;">
                        <li>Click "Copy Data" below</li>
                        <li>Open your Google Sheet</li>
                        <li>Go to the Games sheet</li>
                        <li>Click on the first empty row</li>
                        <li>Paste (Ctrl+V or Cmd+V)</li>
                    </ol>
                    <p><strong>${imported} games ready to import</strong> (${skipped} skipped as duplicates)</p>
                    <textarea id="import-data" style="width: 100%; height: 200px; margin: 1rem 0; font-family: monospace; font-size: 0.8rem;" readonly>${csvContent}</textarea>
                    <button class="btn btn-primary" onclick="copyImportData()" style="width: 100%;">Copy Data to Clipboard</button>
                    <button class="btn btn-secondary" onclick="downloadImportCSV('${username}_games.csv')" style="width: 100%; margin-top: 0.5rem;">Download as CSV</button>
                `;
                
                // Store data for download function
                window.importCSVContent = csvContent;
                
            } catch (error) {
                showStatus('Error preparing import: ' + error.message, 'error');
            }
        }
        
        function copyImportData() {
            const textarea = document.getElementById('import-data');
            textarea.select();
            document.execCommand('copy');
            showStatus('Data copied to clipboard! Now paste it into your Google Sheet.', 'success');
        }
        
        function downloadImportCSV(filename) {
            const csvContent = window.importCSVContent;
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('hidden', '');
            a.setAttribute('href', url);
            a.setAttribute('download', filename);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            showStatus('CSV file downloaded!', 'success');
        }
        
        // Export functions
        function exportPlayHistory() {
            const plays = playHistory;
            let csv = 'Timestamp,Game ID,Game Title,Players,Notes,Winner,Rating,Session ID\n';
            
            plays.forEach(play => {
                const game = allGames.find(g => g.id === play.gameId);
                csv += `"${play.timestamp}","${play.gameId}","${game?.title || ''}","${play.players || ''}","${play.notes || ''}","${play.winner || ''}","${play.rating || ''}","${play.sessionId || ''}"\n`;
            });
            
            downloadCSV(csv, 'play_history.csv');
        }
        
        function exportInventory() {
            const games = allGames;
            let csv = 'Game ID,Title,Current Location,BGG ID,Photo URL\n';
            
            games.forEach(game => {
                csv += `"${game.id}","${game.title}","${game.location}","${game.bggId || ''}","${game.photoUrl || ''}"\n`;
            });
            
            downloadCSV(csv, 'game_inventory.csv');
        }
        
        function downloadCSV(csv, filename) {
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.setAttribute('hidden', '');
            a.setAttribute('href', url);
            a.setAttribute('download', filename);
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // Data loading functions
        async function loadAllGames() {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            if (!spreadsheetId || !apiKey) {
                console.error('No spreadsheet ID or API key found for loading games');
                showStatus('Please configure Google Sheets settings first', 'error');
                return [];
            }
            
            // Check if we have recent cached data
            const now = Date.now();
            if (allGames.length > 0 && gameCache.size > 0 && (now - cacheTimestamp) < CACHE_DURATION) {
                console.log('Using cached games data');
                return allGames;
            }
            
            try {
                console.log('Fetching games from Google Sheets...');
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/Games!A:E?key=${apiKey}`
                );
                
                if (response.status === 429) {
                    // If rate limited and we have cached data, use it
                    if (allGames.length > 0) {
                        console.log('Rate limited - using cached data');
                        showStatus('Using cached data due to rate limit', 'warning');
                        return allGames;
                    }
                    throw new Error('API rate limit exceeded. Please wait and try again.');
                }
                
                if (!response.ok) {
                    console.error('Failed to load games:', response.status, response.statusText);
                    throw new Error(`Failed to load games: ${response.status}`);
                }
                
                const data = await response.json();
                const rows = data.values || [];
                
                console.log('Games sheet raw data:', rows.length, 'rows');
                
                // Clear caches
                allGames = [];
                gameCache.clear();
                cacheTimestamp = now;
                
                for (let i = 1; i < rows.length; i++) {
                    const [gameId, title, location, bggId, photoUrl] = rows[i];
                    const game = {
                        id: gameId,
                        title: title || 'Unknown Game',
                        location: location || 'Unknown',
                        bggId: bggId || '',
                        photoUrl: photoUrl || ''
                    };
                    allGames.push(game);
                    gameCache.set(gameId, game);
                }
                
                console.log(`Loaded ${allGames.length} games from spreadsheet`);
                return allGames;
            } catch (error) {
                console.error('Error loading games:', error);
                showStatus('Error loading games: ' + error.message, 'error');
                return allGames; // Return cached data if available
            }
        }
        
        async function loadAllBins() {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            if (!spreadsheetId || !apiKey) {
                return [];
            }
            
            try {
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/Bins!A:B?key=${apiKey}`
                );
                
                const data = await response.json();
                const rows = data.values || [];
                
                allBins = [];
                for (let i = 1; i < rows.length; i++) {
                    const [binId, description] = rows[i];
                    allBins.push({
                        id: binId,
                        description: description || ''
                    });
                }
                
                return allBins;
            } catch (error) {
                console.error('Error loading bins:', error);
                return [];
            }
        }
        
        async function loadPlayHistory() {
            return loadEnhancedPlayHistory();
        }
        
        // QR Code processing
        function processManualQR() {
            const input = document.getElementById('manual-qr-input').value.trim();
            if (!input) {
                showStatus('Please enter a QR code value', 'error');
                return;
            }
            
            console.log('Processing manual QR entry:', input);
            
            // Process it as if it was scanned
            onScanSuccess(input, null);
            
            // Clear the input
            document.getElementById('manual-qr-input').value = '';
        }
        
        // QR Code Scanning
        function startScanning() {
            // Check if library is loaded
            if (typeof Html5Qrcode === 'undefined') {
                showStatus('QR scanner library not loaded. Please refresh the page.', 'error');
                console.error('Html5Qrcode library not found');
                return;
            }
            
            console.log('Starting camera scan...');
            showStatus('Initializing camera...', 'success');
            
            const config = { 
                fps: 10, 
                qrbox: { width: 250, height: 250 },
                aspectRatio: 1.0
            };
            
            html5QrcodeScanner = new Html5Qrcode("reader");
            
            html5QrcodeScanner.start(
                { facingMode: "environment" },
                config,
                (decodedText, decodedResult) => {
                    console.log('Scan successful:', decodedText);
                    onScanSuccess(decodedText, decodedResult);
                },
                (errorMessage) => {
                    // Silent fail during scanning
                }
            ).then(() => {
                console.log('Camera started successfully');
                showStatus('Camera ready - point at QR code', 'success');
            }).catch(err => {
                console.error('Camera error:', err);
                let errorMsg = 'Unable to access camera. ';
                if (err.name === 'NotAllowedError') {
                    errorMsg += 'Please allow camera permissions and refresh the page.';
                } else if (err.name === 'NotFoundError') {
                    errorMsg += 'No camera found on this device.';
                } else {
                    errorMsg += err.message || 'Please check permissions.';
                }
                showStatus(errorMsg, 'error');
            });
        }
        
        function stopScanning() {
            if (html5QrcodeScanner) {
                html5QrcodeScanner.stop().then(() => {
                    console.log('Camera stopped successfully');
                    html5QrcodeScanner = null;
                }).catch(err => console.error('Error stopping camera:', err));
            }
        }
        
        function onScanSuccess(decodedText, decodedResult) {
            // Stop the scanner immediately to prevent multiple scans
            if (html5QrcodeScanner) {
                html5QrcodeScanner.stop().catch(err => console.log('Stop error:', err));
            }
            
            // Parse QR code data
            const data = parseQRCode(decodedText);
            
            if (!data) {
                showStatus('Invalid QR code format: ' + decodedText, 'error');
                // Restart scanner after error
                setTimeout(() => startScanning(), 2000);
                return;
            }
            
            // Handle based on current mode
            switch (currentMode) {
                case 'view':
                    handleViewBin(data);
                    break;
                case 'history':
                    handleGameHistory(data);
                    break;
                case 'play':
                    handleLogPlay(data);
                    break;
                case 'checkout':
                    handleCheckout(data);
                    break;
                case 'checkin':
                    handleCheckin(data);
                    break;
            }
        }
        
        function parseQRCode(text) {
            // Handle multiple QR code formats
            text = text.trim();
            console.log('Parsing QR code:', text);
            
            // Format 0: Google Drive URLs - Extract folder ID
            if (text.includes('drive.google.com')) {
                // Extract folder ID from various Google Drive URL formats
                let folderId = null;
                
                // Format: https://drive.google.com/drive/folders/FOLDER_ID
                const folderMatch = text.match(/\/folders\/([a-zA-Z0-9-_]+)/);
                if (folderMatch) {
                    folderId = folderMatch[1];
                }
                
                // Format: https://drive.google.com/open?id=FOLDER_ID
                if (!folderId) {
                    const openMatch = text.match(/[?&]id=([a-zA-Z0-9-_]+)/);
                    if (openMatch) {
                        folderId = openMatch[1];
                    }
                }
                
                if (folderId) {
                    return {
                        type: 'BIN',
                        id: folderId,
                        isGoogleDrive: true
                    };
                }
            }
            
            // Format 1: "TYPE:ID" (e.g., "BIN:001" or "GAME:BGG123")
            if (text.includes(':')) {
                const parts = text.split(':');
                const type = parts[0].toUpperCase();
                // Keep the full text as ID to match what's in the spreadsheet
                return {
                    type: type,
                    id: text.toUpperCase()
                };
            }
            
            // Format 2: "Bin 001" or "bin 001" (space-separated)
            const spaceMatch = text.match(/^(bin|game)\s+(.+)$/i);
            if (spaceMatch) {
                return {
                    type: spaceMatch[1].toUpperCase(),
                    id: spaceMatch[1].toUpperCase() + ':' + spaceMatch[2]
                };
            }
            
            // Format 3: Just numbers like "001" - assume it's a bin
            if (/^\d+$/.test(text)) {
                return {
                    type: 'BIN',
                    id: 'BIN:' + text.padStart(3, '0')
                };
            }
            
            // Format 4: "Bin001" or "Game001" (no space or separator)
            const noSpaceMatch = text.match(/^(bin|game)(\d+)$/i);
            if (noSpaceMatch) {
                return {
                    type: noSpaceMatch[1].toUpperCase(),
                    id: noSpaceMatch[1].toUpperCase() + ':' + noSpaceMatch[2].padStart(3, '0')
                };
            }
            
            // Format 5: Other URL formats
            if (text.includes('http')) {
                // Extract any numbers or identifiers from URL
                const urlMatch = text.match(/(?:bin|game)[:\s-]?(\d+)/i);
                if (urlMatch) {
                    return {
                        type: text.toLowerCase().includes('game') ? 'GAME' : 'BIN',
                        id: (text.toLowerCase().includes('game') ? 'GAME:' : 'BIN:') + urlMatch[1].padStart(3, '0')
                    };
                }
            }
            
            // If no format matches, return null
            console.log('QR code format not recognized');
            return null;
        }
        
        // Mode Handlers
        async function handleViewBin(data) {
            if (data.type !== 'BIN') {
                showStatus('Please scan a bin QR code', 'error');
                // Restart scanner
                setTimeout(() => startScanning(), 2000);
                return;
            }
            
            showStatus('Loading bin contents...', 'success');
            
            try {
                const [games, binInfo] = await Promise.all([
                    getGamesInBin(data.id),
                    getBinInfo(data.id)
                ]);
                
                displayBinContents(data.id, games, binInfo);
                // Don't automatically restart scanning
            } catch (error) {
                showStatus('Error loading bin contents: ' + error.message, 'error');
                // Restart scanner on error
                setTimeout(() => startScanning(), 2000);
            }
        }
        
        // Google Sheets Integration
        async function getGamesInBin(binId) {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            if (!spreadsheetId || !apiKey) {
                throw new Error('Please configure Google Sheets settings');
            }
            
            try {
                // Fetch all games from the Games sheet
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/Games!A:E?key=${apiKey}`
                );
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                const rows = data.values || [];
                
                // Skip header row and filter games in this bin
                const gamesInBin = [];
                for (let i = 1; i < rows.length; i++) {
                    const [gameId, title, location, bggId, photoUrl] = rows[i];
                    if (location === binId) {
                        gamesInBin.push({
                            id: gameId,
                            title: title || 'Unknown Game',
                            location: location,
                            bggId: bggId || '',
                            photoUrl: photoUrl || ''
                        });
                    }
                }
                
                return gamesInBin;
            } catch (error) {
                console.error('Error fetching games:', error);
                throw error;
            }
        }
        
        async function getGameInfo(gameId) {
            // Check cache first
            const now = Date.now();
            if (gameCache.has(gameId) && (now - cacheTimestamp) < CACHE_DURATION) {
                console.log('Using cached game info for:', gameId);
                return gameCache.get(gameId);
            }
            
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            try {
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/Games!A:E?key=${apiKey}`
                );
                
                if (response.status === 429) {
                    throw new Error('API rate limit exceeded. Please wait a moment and try again.');
                }
                
                if (!response.ok) {
                    throw new Error(`API Error: ${response.status}`);
                }
                
                const data = await response.json();
                const rows = data.values || [];
                
                // Clear and rebuild cache
                gameCache.clear();
                cacheTimestamp = now;
                
                // Cache all games while we're at it
                for (let i = 1; i < rows.length; i++) {
                    const game = {
                        id: rows[i][0],
                        title: rows[i][1] || 'Unknown Game',
                        location: rows[i][2] || 'Unknown',
                        bggId: rows[i][3] || '',
                        photoUrl: rows[i][4] || ''
                    };
                    gameCache.set(game.id, game);
                }
                
                // Return the requested game
                return gameCache.get(gameId) || null;
                
            } catch (error) {
                console.error('Error fetching game info:', error);
                
                // If we have cached data, use it even if expired
                if (gameCache.has(gameId)) {
                    console.log('Using expired cache due to API error');
                    return gameCache.get(gameId);
                }
                
                throw error;
            }
        }
        
        async function updateGameLocation(gameId, newLocation) {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            const appsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            try {
                // First, find which row contains this game
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/Games!A:A?key=${apiKey}`
                );
                
                const data = await response.json();
                const gameIds = data.values || [];
                
                let rowIndex = -1;
                for (let i = 1; i < gameIds.length; i++) {
                    if (gameIds[i][0] === gameId) {
                        rowIndex = i + 1; // +1 because sheets are 1-indexed
                        break;
                    }
                }
                
                if (rowIndex === -1) {
                    throw new Error(`Game ${gameId} not found`);
                }
                
                // If Apps Script URL is available, use it
                if (appsScriptUrl) {
                    const scriptResponse = await fetch(appsScriptUrl, {
                        method: 'POST',
                        mode: 'no-cors',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify({
                            action: 'update',
                            sheet: 'Games',
                            row: rowIndex,
                            col: 3, // Column C
                            value: newLocation
                        })
                    });
                    
                    return true;
                }
                
                // Otherwise provide manual instruction
                const gameInfo = await getGameInfo(gameId);
                showStatus(`Please update row ${rowIndex} in your Games sheet: Change location of "${gameInfo.title}" to "${newLocation}"`, 'error');
                return false;
                
            } catch (error) {
                console.error('Error updating game location:', error);
                throw error;
            }
        }
        
        async function getBinInfo(binId) {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            try {
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}/values/Bins!A:B?key=${apiKey}`
                );
                
                const data = await response.json();
                const rows = data.values || [];
                
                // Find the bin
                for (let i = 1; i < rows.length; i++) {
                    if (rows[i][0] === binId) {
                        return {
                            id: rows[i][0],
                            description: rows[i][1] || 'No description'
                        };
                    }
                }
                
                return null;
            } catch (error) {
                console.error('Error fetching bin info:', error);
                throw error;
            }
        }
        
        // UI Helper Functions
        function showStatus(message, type) {
            const statusDiv = document.getElementById('status-message');
            statusDiv.textContent = message;
            statusDiv.className = `status-message status-${type}`;
            statusDiv.classList.remove('hidden');
            
            setTimeout(() => {
                statusDiv.classList.add('hidden');
            }, 5000);
        }
        
        function showWorkflowState(message) {
            const stateDiv = document.getElementById('workflow-state');
            stateDiv.textContent = message;
            stateDiv.classList.remove('hidden');
        }
        
        function hideWorkflowState() {
            document.getElementById('workflow-state').classList.add('hidden');
        }
        
        function hideStatus() {
            document.getElementById('status-message').classList.add('hidden');
        }
        
        function hideResults() {
            document.getElementById('results').classList.add('hidden');
        }
        
        function displayBinContents(binId, games, binInfo) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('results-content');
            
            // For Google Drive IDs, show a shortened version
            let displayId = binId;
            if (binId.length > 20 && !binId.includes(':')) {
                displayId = 'Bin ' + binId.substring(0, 8) + '...';
            }
            
            const binDesc = binInfo ? binInfo.description : 'No description';
            contentDiv.innerHTML = `<h4>üì¶ ${displayId}</h4><p style="color: #7f8c8d; margin-bottom: 1rem;">${binDesc}</p>`;
            
            if (games.length === 0) {
                contentDiv.innerHTML += '<p style="text-align: center; color: #95a5a6; padding: 2rem;">No games currently in this bin</p>';
            } else {
                contentDiv.innerHTML += `<p style="margin-bottom: 1rem;">Found ${games.length} game${games.length !== 1 ? 's' : ''}:</p>`;
                games.forEach(game => {
                    contentDiv.innerHTML += `
                        <div class="result-item">
                            ${game.photoUrl ? `<img src="${game.photoUrl}" class="game-thumbnail" alt="${game.title}">` : ''}
                            <div class="result-item-content">
                                <div class="game-title">üé≤ ${game.title}</div>
                                <div class="game-location">ID: ${game.id}${game.bggId ? ' ‚Ä¢ BGG: ' + game.bggId : ''}</div>
                            </div>
                            <button class="btn btn-info" onclick="viewGameHistoryById('${game.id}')" style="margin-left: auto;">History</button>
                        </div>
                    `;
                });
            }
            
            resultsDiv.classList.remove('hidden');
        }
        
        function displayGamePlayInfo(gameInfo) {
            const resultsDiv = document.getElementById('results');
            const contentDiv = document.getElementById('results-content');
            
            contentDiv.innerHTML = `
                <h4>üéÆ Game Played</h4>
                <div class="result-item">
                    ${gameInfo.photoUrl ? `<img src="${gameInfo.photoUrl}" class="game-thumbnail" alt="${gameInfo.title}">` : ''}
                    <div class="result-item-content">
                        <div class="game-title">${gameInfo.title}</div>
                        <div class="game-location">Current Location: ${gameInfo.location}</div>
                        ${gameInfo.bggId ? '<div class="game-location">BGG ID: ' + gameInfo.bggId + '</div>' : ''}
                    </div>
                </div>
            `;
            
            resultsDiv.classList.remove('hidden');
        }
        
        // Settings Management
        function saveSettings() {
            const spreadsheetId = document.getElementById('spreadsheet-id').value;
            const apiKey = document.getElementById('api-key').value;
            
            if (spreadsheetId && apiKey) {
                localStorage.setItem('spreadsheetId', spreadsheetId);
                localStorage.setItem('apiKey', apiKey);
                showStatus('Settings saved successfully!', 'success');
                
                // Test the connection
                testConnection();
            } else {
                showStatus('Please fill in all settings', 'error');
            }
        }
        
        function savePhotoSettings() {
            const photoFolderId = document.getElementById('photo-folder-id').value;
            
            if (photoFolderId) {
                localStorage.setItem('photoFolderId', photoFolderId);
                showStatus('Photo settings saved successfully!', 'success');
            } else {
                showStatus('Please enter a folder ID', 'error');
            }
        }
        
        async function testConnection() {
            try {
                const spreadsheetId = localStorage.getItem('spreadsheetId');
                const apiKey = localStorage.getItem('apiKey');
                
                const response = await fetch(
                    `${SHEETS_API_BASE}/${spreadsheetId}?key=${apiKey}`
                );
                
                if (response.ok) {
                    showStatus('‚úÖ Successfully connected to Google Sheets!', 'success');
                } else {
                    showStatus('‚ùå Connection failed. Please check your settings.', 'error');
                }
            } catch (error) {
                showStatus('‚ùå Connection error: ' + error.message, 'error');
            }
        }
        
        function saveAppsScriptUrl() {
            const scriptUrl = document.getElementById('apps-script-url').value;
            
            if (scriptUrl) {
                localStorage.setItem('appsScriptUrl', scriptUrl);
                showStatus('Apps Script URL saved! Automatic updates are now enabled.', 'success');
                
                // Update header to show auto-update is enabled
                const header = document.querySelector('h1');
                header.innerHTML = 'üé≤ BoardGame Collection Manager <span style="font-size: 0.7rem; background: #27ae60; padding: 0.2rem 0.5rem; border-radius: 4px; margin-left: 0.5rem;">Auto-Update Enabled</span>';
            } else {
                localStorage.removeItem('appsScriptUrl');
                showStatus('Apps Script URL removed', 'success');
                
                // Remove auto-update indicator
                const header = document.querySelector('h1');
                header.innerHTML = 'üé≤ BoardGame Collection Manager';
            }
        }
        
        function loadSettings() {
            // Pre-fill with user's credentials
            const savedSpreadsheetId = localStorage.getItem('spreadsheetId');
            const savedApiKey = localStorage.getItem('apiKey');
            const savedPhotoFolderId = localStorage.getItem('photoFolderId');
            const savedAppsScriptUrl = localStorage.getItem('appsScriptUrl');
            
            // Always show the credentials in the fields
            document.getElementById('spreadsheet-id').value = savedSpreadsheetId || '1jf1ub1x0y6oal1So5rUHVANip5WeoAaoQgDyEOPS3fM';
            document.getElementById('api-key').value = savedApiKey || 'AIzaSyDMvS1WL5kEjfSgq2V1uKmlfvJIwSPfpqo';
            document.getElementById('photo-folder-id').value = savedPhotoFolderId || '';
            document.getElementById('apps-script-url').value = savedAppsScriptUrl || '';
            
            // Show first-time notice if credentials are not yet saved
            if (!savedSpreadsheetId || !savedApiKey) {
                document.getElementById('first-time-notice').style.display = 'block';
            }
            
            // Update header to show if automatic updates are enabled
            if (savedAppsScriptUrl) {
                const header = document.querySelector('h1');
                header.innerHTML = 'üé≤ BoardGame Collection Manager <span style="font-size: 0.7rem; background: #27ae60; padding: 0.2rem 0.5rem; border-radius: 4px; margin-left: 0.5rem;">Auto-Update Enabled</span>';
            }
        }
        
        // Geek Group Integration Functions
        function saveGeekGroupUsername() {
            const username = document.getElementById('geekgroup-username').value.trim();
            
            if (!username) {
                showStatus('Please enter your BGG username', 'error');
                return;
            }
            
            localStorage.setItem('bggUsername', username);
            showStatus('BGG username saved!', 'success');
        }
        
        function loadGeekGroupUsername() {
            const savedUsername = localStorage.getItem('bggUsername');
            if (savedUsername) {
                document.getElementById('geekgroup-username').value = savedUsername;
            }
        }
        
        function openGeekGroup() {
            const username = document.getElementById('geekgroup-username').value.trim();
            
            if (!username) {
                showStatus('Please enter your BGG username first', 'error');
                return;
            }
            
            // Save the username
            localStorage.setItem('bggUsername', username);
            
            // Construct Geek Group URL with correct format
            const geekGroupUrl = `https://geekgroup.app/users/${username}/collection`;
            
            // Option 1: Open in new tab (recommended)
            window.open(geekGroupUrl, '_blank');
            
            // Option 2: Try to embed (uncomment if Geek Group allows iframes)
            /*
            const iframeContainer = document.getElementById('geekgroup-iframe-container');
            const iframe = document.getElementById('geekgroup-iframe');
            iframe.src = geekGroupUrl;
            iframeContainer.style.display = 'block';
            */
        }
        
        // Update the stats tab handler
        function setStatsTab(tab) {
            statsTab = tab;
            
            // Remove active class from all tabs
            document.querySelectorAll('#stats-section .tab').forEach(t => t.classList.remove('active'));
            
            // Add active class to the selected tab
            document.querySelectorAll('#stats-section .tab').forEach(t => {
                if ((tab === 'overview' && t.textContent === 'Overview') ||
                    (tab === 'trends' && t.textContent === 'Play Trends') ||
                    (tab === 'ratings' && t.textContent === 'Ratings') ||
                    (tab === 'sessions' && t.textContent === 'Session Analysis') ||
                    (tab === 'value' && t.textContent === 'Collection Value')) {
                    t.classList.add('active');
                }
            });
            
            // Hide all stats content
            document.querySelectorAll('.stats-content').forEach(content => {
                content.classList.add('hidden');
            });
            
            // Show selected content
            switch(tab) {
                case 'overview':
                    document.getElementById('stats-overview').classList.remove('hidden');
                    break;
                case 'trends':
                    document.getElementById('stats-trends').classList.remove('hidden');
                    updateTrendsChart();
                    break;
                case 'ratings':
                    document.getElementById('stats-ratings').classList.remove('hidden');
                    updateRatingsDisplay();
                    break;
                case 'sessions':
                    document.getElementById('stats-sessions').classList.remove('hidden');
                    updateSessionAnalysis();
                    break;
                case 'value':
                    document.getElementById('stats-value').classList.remove('hidden');
                    loadGeekGroupUsername();
                    break;
            }
        }

        // Add a quick link button to game history modal
        function addGeekGroupButton(bggId) {
            const username = localStorage.getItem('bggUsername');
            if (username && bggId) {
                // You might need to check if Geek Group supports direct game links
                // For now, this will take them to their collection
                return `
                    <button class="btn btn-info" onclick="window.open('https://geekgroup.app/users/${username}/collection', '_blank')">
                        üìä View Collection on Geek Group
                    </button>
                `;
            }
            return '';
        }

        async function testGoogleSheetsConnection() {
            const spreadsheetId = localStorage.getItem('spreadsheetId');
            const apiKey = localStorage.getItem('apiKey');
            
            console.log('Spreadsheet ID:', spreadsheetId);
            console.log('API Key:', apiKey ? 'Set' : 'Not set');
            
            if (!spreadsheetId || !apiKey) {
                console.error('Missing credentials!');
                return;
            }
            
            try {
                const response = await fetch(
                    `https://sheets.googleapis.com/v4/spreadsheets/${spreadsheetId}/values/Games!A1:E1?key=${apiKey}`
                );
                console.log('API Response Status:', response.status);
                
                if (response.ok) {
                    const data = await response.json();
                    console.log('Headers:', data.values?.[0]);
                } else {
                    console.error('API Error:', await response.text());
                }
            } catch (error) {
                console.error('Connection error:', error);
            }
        }

        function debugUI() {
            console.log('=== UI Debug ===');
            console.log('Current Mode:', currentMode);
            console.log('Search Tab:', searchTab);
            console.log('Games Loaded:', allGames.length);
            console.log('Players Loaded:', allPlayers.length);
            
            // Check visibility of sections
            const sections = [
                'scan-section', 'search-section', 'stats-section', 
                'players-section', 'sessions-section', 'bulk-section', 
                'bgg-section', 'settings-section', 'results'
            ];
            
            sections.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    console.log(`${id}:`, elem.classList.contains('hidden') ? 'HIDDEN' : 'VISIBLE');
                } else {
                    console.log(`${id}: NOT FOUND`);
                }
            });
            
            console.log('=== End Debug ===');
        }

        function testSections() {
            const sections = ['search-section', 'players-section', 'sessions-section', 
                             'bulk-section', 'bgg-section', 'settings-section'];
            
            sections.forEach(id => {
                const elem = document.getElementById(id);
                if (!elem) {
                    console.error(`Section ${id} not found!`);
                } else {
                    console.log(`Section ${id} exists, hidden: ${elem.classList.contains('hidden')}`);
                }
            });
        }

        function debugSectionVisibility() {
            const sections = ['scan-section', 'search-section', 'stats-section', 
                             'players-section', 'sessions-section', 'bulk-section', 
                             'bgg-section', 'settings-section'];
            
            sections.forEach(id => {
                const elem = document.getElementById(id);
                if (elem) {
                    const rect = elem.getBoundingClientRect();
                    const computed = window.getComputedStyle(elem);
                    console.log(`${id}:`, {
                        hidden: elem.classList.contains('hidden'),
                        display: computed.display,
                        visibility: computed.visibility,
                        height: rect.height,
                        top: rect.top,
                        isInViewport: rect.top < window.innerHeight && rect.bottom > 0
                    });
                }
            });
        }
        
    </script>
</body>
</html>
